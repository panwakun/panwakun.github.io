<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Tag: Android - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Hexo</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Android</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:05:15.000Z" title="2020-12-19T11:05:15.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:05:48.593Z" title="2020-12-19T11:05:48.593Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/Gson%E5%A2%9E%E9%87%8F%E8%A7%A3%E6%9E%90/">Gson增量解析</a></h1><div class="content"><p>增量解析是我自己杜撰的一个名词，主要是有这样的场景，移动端请求服务端json数据的时候，考虑到流量资源的珍贵，如果本地已经请求过完整下信息，一般是将一个model更新的字段下发，而不是每次都下发完整的model。举个例子，我们向服务器请求user的信息，完整的数据格式可能是：</p>
<blockquote>
<p>{“age”:20,”id”:1,”name”:”张三”,”sex”:”男”}</p>
</blockquote>
<p>User中的id、name、sex可能是一直不变的，而age是有可能发生变化的，当客户端刷新user的信息时，服务端只下发age的信息就行了，以达到节省流量的目的，下发的数据格式可能是：</p>
<blockquote>
<p>{“age”:25,”id”:1}</p>
</blockquote>
<p>只有age发生变化，所以只下发了age的信息，id作为识别字段。我们用Gson解析的时候一般是直接调用fromJson函数，这个函数接受两个参数，一个是json字符串，一个是解析的model类。对于这种只有部分数据的json我们如何解析呢，难道重新定义一个SubUser类，处理这种解析然后赋值给User吗，这样做的代价是非常不灵活，更新的字段必须客户端写死，如果下次name或者sex也发生了变化呢，是不是SubUser类就需要修改然后发版？</p>
<p>能不能有个类似于fromJson的函数，他的第二个参数不再是一个类，而是一个实例，新的json数据只会更新这个实例的某些字段。Gson在解析的时候会调用model的默认构造函数new出一个实例，能不能不让它new而是直接在原有的实例基础上进行解析呢？查看Gson的官方文档，看到可以给Gson注册一个InstanceCreator，它是一个接口，顾名思义它是提供用户一个初始化model的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface InstanceCreator&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public T createInstance(Type type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把原来的user作为初始化的实例，实现增量更新的解析。这是对于object的解析，可以这么做。如果是list呢，如何进行增量解析呢，总不能把原来的list作为返回值吧，目前我还没有很好的思路，只是将列表拆分成object分别进行解析。</p>
<p>下面简单的写一个demo：</p>
<p>User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line"></span><br><span class="line">    public long id;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public String sex;</span><br><span class="line"></span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GsonCreatorHelper类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class GsonCreatorHelper &#123;</span><br><span class="line"></span><br><span class="line">    public static User fromJson(String json, final User old) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JSONObject object &#x3D; new JSONObject(json);</span><br><span class="line">            long id &#x3D; object.getLong(&quot;id&quot;);</span><br><span class="line">            if (id &#x3D;&#x3D; old.getId()) &#123;</span><br><span class="line">                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(User.class, new InstanceCreator&lt;User&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public User createInstance(Type type) &#123;</span><br><span class="line">                        return old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br><span class="line">                return gson.fromJson(json, User.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Gson().fromJson(json, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;User&gt; fromJson(String json, final List&lt;User&gt; old) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;User&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            JSONArray array &#x3D; new JSONArray(json);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; array.length(); i++) &#123;</span><br><span class="line">                JSONObject object &#x3D; array.getJSONObject(i);</span><br><span class="line">                final long id &#x3D; object.getLong(&quot;id&quot;);</span><br><span class="line">                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(User.class, new InstanceCreator&lt;User&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public User createInstance(Type type) &#123;</span><br><span class="line">                        return getUserById(old, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br><span class="line">                result.add(gson.fromJson(object.toString(), User.class));</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Gson().fromJson(json, new TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static User getUserById(List&lt;User&gt; users, long id) &#123;</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.getId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">                return user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivity测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        String json1 &#x3D; &quot;&#123;\&quot;age\&quot;:20,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;&quot;;</span><br><span class="line">        String json2 &#x3D; &quot;&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:1&#125;&quot;;</span><br><span class="line">        String json3 &#x3D; &quot;[&#123;\&quot;age\&quot;:20,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;,&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;]&quot;;</span><br><span class="line">        String json4 &#x3D; &quot;[&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:1&#125;,&#123;\&quot;age\&quot;:33,\&quot;id\&quot;:2&#125;]&quot;;</span><br><span class="line"></span><br><span class="line">        User user1 &#x3D; new Gson().fromJson(json1, User.class);</span><br><span class="line">        Log.e(&quot;user1&quot;, new Gson().toJson(user1));</span><br><span class="line"></span><br><span class="line">        User user2 &#x3D; GsonCreatorHelper.fromJson(json2, user1);</span><br><span class="line">        Log.e(&quot;user2&quot;, new Gson().toJson(user2));</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; user3 &#x3D; new Gson().fromJson(json3, new TypeToken&lt;ArrayList&lt;User&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">        Log.e(&quot;user3&quot;, new Gson().toJson(user3));</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; user4 &#x3D; GsonCreatorHelper.fromJson(json4, user3);</span><br><span class="line">        Log.e(&quot;user4&quot;, new Gson().toJson(user4));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10-08 18:18:41.419 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user1: &#123;&quot;age&quot;:20,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="line">10-08 18:18:41.425 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user2: &#123;&quot;age&quot;:23,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="line">10-08 18:18:41.436 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user3: [&#123;&quot;age&quot;:20,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:23,&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]</span><br><span class="line">10-08 18:18:41.441 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user4: [&#123;&quot;age&quot;:23,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:33,&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]</span><br></pre></td></tr></table></figure>
<p>从结果中我们可以看到user2和user4都是在user1和user3的基础上继续解析了新的json数据。大功告成！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-17T14:06:52.000Z" title="2020-12-17T14:06:52.000Z">2020-12-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T10:53:36.124Z" title="2020-12-19T10:53:36.124Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/17/HTTPS%E5%8E%9F%E7%90%86%E5%8F%8AOKHTTP%E5%AF%B9HTTPS%E7%9A%84%E6%94%AF%E6%8C%81/">HTTPS原理及OKHTTP对HTTPS的支持</a></h1><div class="content"><h1 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h1><p>我们先看一下定义，来自wikipedia的一个介绍：</p>
<blockquote>
<p>HTTPS  (also called <strong>HTTP over Transport Layer Security (TLS)</strong>, <strong>HTTP over SSL</strong>, and <strong>HTTP Secure</strong>) is a communications protocol for secure communication over a computer network which is widely used on the Internet. HTTPS consists of communication over Hypertext Transfer Protocol (HTTP) within a connection encrypted by Transport Layer Security, or its predecessor, Secure Sockets Layer. The main motivation for HTTPS is authentication of the visited website and protection of the privacy and integrity of the exchanged data.</p>
</blockquote>
<p>从这个定义中我们可以看出，HTTPS是包含了HTTP协议及SSL /TLS协议这两部分内容，简单的理解就是基于SSL/TLS进行HTTP的加密传输。HTTP是一个应用层的协议，定义了很多请求和响应方通信的遵循的规则，这部分内容可以从<a target="_blank" rel="noopener" href="https://www.amazon.cn/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%90%89%E5%B0%94%E5%88%A9/dp/B008XFDQ14/ref=sr_1_1/460-1292118-1495910?s=books&ie=UTF8&qid=1502806302&sr=1-1&keywords=HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">HTTP权威指南</a>这部巨作中得到很详细的介绍，这里就不赘述了。其实主要还是想探讨一下SSL/TLS协议的一些具体细节，毕竟这是HTTPS区别于HTTP最大的地方，首先我们来看一下一个SSL/TLS完整的握手过程。</p>
<p><img src="../images/1.jpeg" alt="SSL/TLS握手过程"></p>
<p>很复杂的交互过程，但是理解下来就是用非对称加密的手段传递密钥，然后用密钥进行对称加密传递数据。在这个握手过程中最重要的就是证书校验，其他就是正常的数据交互过程。如何校验一个证书合法有很大的文章，处理不好就会让你的网络失去了安全性。一个证书的校验，主要包括以下几个方面：</p>
<ul>
<li>第一，校验证书是否是由客户端中“受信任的根证书颁发机构”颁发；</li>
<li>第二，校验证书是否在上级证书的吊销列表；</li>
<li>第三，校验证书是否过期；</li>
<li>第四，校验证书域名是否一致。</li>
</ul>
<p>一天我们的QA妹子气愤愤的找到我说，为啥别人的APP可以用Charles抓到HTTPS的包，为啥我们的不能，我心中窃喜的告诉她只能说明我们技高一筹了。具体如何做到的后面我会分享一下我们的做法，先讨论一下Charles如何实现https的抓包的，这里面涉及到一个中间人攻击的问题。</p>
<p>一个针对SSL的中间人攻击过程如下：</p>
<p><img src="../images/2.jpeg" alt="image.png"></p>
<p>中间人其实是做了一个偷梁换柱的动作，核心是如何欺骗客户端，从而让客户端能够放心的与中间人进行数据交互而没有任何察觉。我们来看Charles如何做到HTTPS抓包的，网上有很多Charles如何抓HTTPS包的教程，几步就搞定了，其中最核心的就是：</p>
<blockquote>
<p>将私有CA签发的数字证书安装到手机中并且作为受信任证书保存</p>
</blockquote>
<p>自签发一个证书实现上述二、三、四条校验规则很简单，要把这个证书安装到手机端信任列表必须得到用户的许可，这里不好绕过，但是鉴于大部分用户的网络安全意识比较差，有时也会稀里糊涂的信任了，那我们作为APP的开发人员，能否避免这种情况的发生呢？</p>
<p>其实也很简单，我们把服务端的证书内置在我们的APP里，我们在做服务端证书校验的时候只比对是否和这个证书完全相同，不同就直接抛错，那中间人便没有办法绕过证书进行攻击。但是这里面也有一个问题就是服务端的证书可能会过期或者升级，而且服务端往往为了提高网络的安全性，证书的有效时间不会设置太长，这样APP就会因为这个证书的事情频繁发版，也很痛苦。（前段时间我司IOS的APP就是因为授权企业用户的证书没有及时更新，导致大家无法正常打开APP，血的教训导致我们不想重走这条路）可能你又想到了，我们可以把证书配置在后端，有更新的时候直接去下载不就完了，那我们的证书下载没有没拦截的风险吗，一旦拦截，我们所有的证书校验都会失效，比直接信任手机内置的证书更可怕。我们既不想只信任我们服务器的证书，又不想信任手机上所有的 CA 证书。有个不错的的信任方式是把签发我们服务器的证书的根证书导出打包到APP中，这样虽然不能做到百分之百的证书无漏洞，但是相比于信任手机中几百个证书，我们只信任一个风险会小很多，这也就是我们的QA妹子用Charles抓不了我们的包的原因。~~~</p>
<h1 id="OKHTTP"><a href="#OKHTTP" class="headerlink" title="OKHTTP"></a>OKHTTP</h1><p>作为一个Android开发者，我们来看一下广泛使用的网络库OKHTTP对于HTTPS的支持。下面这段话摘自OKHTTP对于HTTPS的介绍中（<a target="_blank" rel="noopener" href="https://github.com/square/okhttp/wiki/HTTPS">地址请戳</a>）：</p>
<p>OkHttp attempts to balance two competing concerns:</p>
<ul>
<li><strong>Connectivity</strong> to as many hosts as possible. That includes advanced hosts that run the latest versions of <a target="_blank" rel="noopener" href="https://boringssl.googlesource.com/boringssl/">boringssl</a> and less out of date hosts running older versions of <a target="_blank" rel="noopener" href="https://www.openssl.org/">OpenSSL</a>.</li>
<li><strong>Security</strong> of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers.</li>
</ul>
<p>几个与HTTPS相关的API：</p>
<h3 id="SSLSocketFactory"><a href="#SSLSocketFactory" class="headerlink" title="SSLSocketFactory:"></a>SSLSocketFactory:</h3><p>安全套接层工厂，用于创建SSLSocket。默认的SSLSocket是信任手机内置信任的证书列表，我们可以通过OKHttpClient.Builder的sslSocketFactory方法定义我们自己的信任策略，比如实现上面提到的我们只信任服务端证书的根证书，代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 载入证书</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static SSLSocketFactory getSSLSocketFactory(InputStream... certificates) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">&#x2F;&#x2F;用我们的证书创建一个keystore</span><br><span class="line">            CertificateFactory certificateFactory &#x3D; CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">            KeyStore keyStore &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            keyStore.load(null);</span><br><span class="line">            int index &#x3D; 0;</span><br><span class="line">            for (InputStream certificate : certificates) &#123;</span><br><span class="line">                String certificateAlias &#x3D; &quot;server&quot;+Integer.toString(index++);</span><br><span class="line">                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (certificate !&#x3D; null) &#123;</span><br><span class="line">                        certificate.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;创建一个trustmanager，只信任我们创建的keystore</span><br><span class="line">            SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            TrustManagerFactory trustManagerFactory &#x3D;</span><br><span class="line">                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            trustManagerFactory.init(keyStore);</span><br><span class="line">            sslContext.init(</span><br><span class="line">                    null,</span><br><span class="line">                    trustManagerFactory.getTrustManagers(),</span><br><span class="line">                    new SecureRandom()</span><br><span class="line">            );</span><br><span class="line">            return sslContext.getSocketFactory();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="X509TrustManager"><a href="#X509TrustManager" class="headerlink" title="X509TrustManager:"></a>X509TrustManager:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface X509TrustManager extends TrustManager &#123;</span><br><span class="line">    void checkClientTrusted(X509Certificate[] var1, String var2) throws CertificateException;</span><br><span class="line"></span><br><span class="line">    void checkServerTrusted(X509Certificate[] var1, String var2) throws CertificateException;</span><br><span class="line"></span><br><span class="line">    X509Certificate[] getAcceptedIssuers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkServerTrusted方式实现了对于服务端校验，这里一般使用系统默认的实现，有些教程讲到这样配置ssl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        sslContext.init(null, new TrustManager[]&#123;</span><br><span class="line">                new X509TrustManager() &#123;</span><br><span class="line">                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        return new X509Certificate[0];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, null);</span><br><span class="line">        return sslContext.getSocketFactory();</span><br><span class="line">    &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>千万不能这么做，这样将你是没有做任何校验的，这里推荐使用系统默认的，他会在校验过程中发现有异常直接抛出。</p>
<h3 id="HostnameVerifier"><a href="#HostnameVerifier" class="headerlink" title="HostnameVerifier:"></a>HostnameVerifier:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HostnameVerifier &#123;</span><br><span class="line">    boolean verify(String var1, SSLSession var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口主要实现对于域名的校验，OKHTTP实现了一个OkHostnameVerifier，对于证书中的IP及Host做了各种正则匹配，默认情况下使用的是这个策略。有时你遇到了一些奇怪的校验问题，大部分教程会教你这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OKHttpClient.Builder.hostnameVerifier(new HostnameVerifier() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>
<p>其实这样你是完全放弃了hostname的校验，这也是相当不安全的。</p>
</div></article></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Hexo</a><p class="is-size-7"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>