<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="website"><meta property="og:title" content="Hexo"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Hexo"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Hexo","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Hexo</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:20:08.000Z" title="2020-12-19T11:20:08.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:21:27.067Z" title="2020-12-19T11:21:27.067Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Platform-Channel/">底层原理 - 深入探索Platform Channel</a></h1><div class="content"><p>Flutter 提供了完善的 Platform Channel 机制供 Native 与 Flutter 端进行相互通信，本节由浅入深，详细探索 Platform Channel 的实现细节。</p>
<h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p>首先我们简单介绍下 Platform Channel 的使用姿势，Flutter提供了三种Channel的方式：</p>
<ul>
<li>BaseMessageChannel，消息的传递，用于数据的传递。</li>
<li>MethodChannel，方法的传递，用于方法调用，传递参数并返回执行结果。</li>
<li>EventChannel，事件的传递，用于Native端对Flutter端高频的通知触发。</li>
</ul>
<h3 id="MethodChannel-Android"><a href="#MethodChannel-Android" class="headerlink" title="MethodChannel - Android"></a>MethodChannel - Android</h3><p>构造函数，通常messenger传递FlutterNativeView实现的DartExecutor, name是Channel匹配的key值，codec是消息传递的编解码，默认是StandardMethodCodec。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodChannel(BinaryMessenger messenger, String name, MethodCodec codec)</span><br></pre></td></tr></table></figure>
<p>调用Flutter端方法，参数依次是方法名、参数以及返回值的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeMethod(String method, Object arguments, MethodChannel.Result callback)</span><br></pre></td></tr></table></figure>
<p>设置方法被调用的处理器，Flutter调用原生代码会调用handler的onMethodCall方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setMethodCallHandler(MethodChannel.MethodCallHandler handler)</span><br></pre></td></tr></table></figure>
<h3 id="MethodChannel-iOS"><a href="#MethodChannel-iOS" class="headerlink" title="MethodChannel - iOS"></a>MethodChannel - iOS</h3><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithName:(NSString*)name</span><br><span class="line">             binaryMessenger:(NSObject&lt;FlutterBinaryMessenger&gt;*)messenger</span><br><span class="line">                       codec:(NSObject&lt;FlutterMessageCodec&gt;*)codec;</span><br></pre></td></tr></table></figure>
<p>调用Flutter方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)invokeMethod:(NSString*)method</span><br><span class="line">           arguments:(id _Nullable)arguments</span><br><span class="line">              result:(FlutterResult _Nullable)callback</span><br></pre></td></tr></table></figure>
<p>设置方法回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMethodCallHandler:(FlutterMethodCallHandler _Nullable)handler;</span><br></pre></td></tr></table></figure>
<h3 id="MethodChannel-Flutter"><a href="#MethodChannel-Flutter" class="headerlink" title="MethodChannel - Flutter"></a>MethodChannel - Flutter</h3><p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- MethodChannel(this.name, [this.codec &#x3D; const StandardMethodCodec()])</span><br></pre></td></tr></table></figure>
<p>调用Native方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- invokeMethod(String method, [dynamic arguments])</span><br></pre></td></tr></table></figure>
<p>设置方法回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- setMethodCallHandler(Future&lt;dynamic&gt; handler(MethodCall call))</span><br></pre></td></tr></table></figure>
<p>BaseMessageChannel、EventChannel和MethodChannel的使用方式十分类似，这里就不一一赘述了。</p>
<h1 id="怎么实现的"><a href="#怎么实现的" class="headerlink" title="怎么实现的"></a>怎么实现的</h1><p>Platform Channel 以 engine 为媒介，在 native 端或者 dart 端进行消息的编码，经过 engine 传递，在另一端进行消息的解码，完成整个消息的通信。这个过程涉及到 messager （信使）、<br>codec（编解码器）以及 handler（处理器），下面将分别介绍。</p>
<h2 id="messager"><a href="#messager" class="headerlink" title="messager"></a>messager</h2><p>messager 在整个消息传递过程中，作为信使的角色，实现了完整的消息传递。我们看一下 Android 端 BinaryMessenger 的代码，iOS 和 Dart 部分 API 高度一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface BinaryMessenger &#123;</span><br><span class="line">   </span><br><span class="line">    void send(String channel, ByteBuffer message);</span><br><span class="line"></span><br><span class="line">    void send(String channel, ByteBuffer message, BinaryReply callback);</span><br><span class="line"></span><br><span class="line">    void setMessageHandler(String channel, BinaryMessageHandler handler);</span><br><span class="line"></span><br><span class="line">    interface BinaryMessageHandler &#123;</span><br><span class="line">        </span><br><span class="line">        void onMessage(ByteBuffer message, BinaryReply reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface BinaryReply &#123;</span><br><span class="line">        </span><br><span class="line">        void reply(ByteBuffer reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BinaryMessenger 提供了两个 send 方法，可选择是否回调消息的处理结果，提供了 setMessageHandler 用以处理 Dart 端 Channel 调用的消息处理。BinaryMessenger 的一个具体实现在 DartMessenger，维护了 messageHandlers 和 pendingReplies 两个 HashMap 分别处理 Dart 端消息请求的响应以及自己发送消息之后的回调。具体的消息传递的完成流程我们等会再讲，先分析一下 codec（编解码器）和 handler（处理器）的实现细节。</p>
<h2 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h2><p>让消息在 dart、engine 以及平台（ Android / iOS ）之间自由传递，需要将消息在传递前编码为平台无关的二进制数据，在接收后解码为原始的数据格式。Flutter 提供了两种 codec , BaseMessageChannel 使用了 MessageCodec , EventChannel 和 MethodChannel 使用了 MethodCodec。</p>
<p>MessageCodec 提供了 encodeMessage 和 decodeMessage 两个接口，以 Android 为例，它的代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageCodec&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ByteBuffer encodeMessage(T message);</span><br><span class="line"></span><br><span class="line">    T decodeMessage(ByteBuffer message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flutter 官方默认已经实现的 MessageCodec 有 StandardMessageCodec、BinaryCodec、StringCodec、JSONMessageCodec 。默认已经实现的 MethodCodec 有 StandardMethodCodec、JSONMethodCodec。</p>
<table>
  <tr>
    <th></th>
    <th>Codec</th>
    <th>Desc</th>
  </tr>
  <tr>
    <td rowspan="4"> MessageCodec </td>
    <td > StandardMessageCodec </td>
    <td >支持基础数据格式与二进制之间的转换，包括 Boolean 、Number、String、Byte、List、Map、数组等。</td>
  </tr>
  <tr>
    <td> BinaryCodec </td>
    <td>支持二进制数据的直接传递，实际上是没有做任何编解码，可以通过它做大内存块的数据传递。</td>
  </tr>
  <tr>
    <td> StringCodec </td>
    <td>支持字符串（UTF-8）与二进制之间的转换。</td>
  </tr>
  <tr>
    <td> JSONMessageCodec  </td>
    <td>支持把数据转换为JSON，再调用 StringCodec 的编解码。</td>
  </tr>
  <tr>
    <td rowspan="2"> MethodCodec </td>
    <td> StandardMethodCodec </td>
    <td>调用 StandardMessageCodec 传递方法的名字和参数。</td>
  </tr>
  <tr>
    <td> JSONMethodCodec </td>
    <td>调用 JSONMessageCodec 传递方法的名字和参数。</td>
  </tr>
</table>
消息的编解码方式可以根据自己的需要从系统提供的 Codec 中选取，也可以完全自定义自己的 Codec 满足实际的业务需求。这里想实现一种基于 Protocol Buffers 协议的编解码器,作为一种简单的学习锻炼，后续会发布在 [Github](https://github.com/flutterboom/flutter-triple-sample) 上供大家参考。


<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Flutter 提供了 Handler 作为消息的处理器，用来处理接收方获取的消息。针对 BaseMessageChannel、MethodChannel 和 EventChannel 三种 Channel 分别提供了 IncomingMessageHandler、IncomingMethodCallHandler 和 IncomingStreamRequestHandler 三种 Handler，实际上是分别包装了 MessageHandler 、MethodCallHandler 和 StreamHandler  来处理对方发送过来的消息。</p>
<h3 id="MessageHandler"><a href="#MessageHandler" class="headerlink" title="MessageHandler"></a>MessageHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageHandler&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   void onMessage(T message, Reply&lt;T&gt; reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Reply&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   void reply(T reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onMessage 接收获取的 message ，并提供回调 reply 。</p>
<h3 id="MethodCallHandler"><a href="#MethodCallHandler" class="headerlink" title="MethodCallHandler"></a>MethodCallHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface MethodCallHandler &#123;</span><br><span class="line"></span><br><span class="line">    void onMethodCall(MethodCall call, Result result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Result &#123;</span><br><span class="line"></span><br><span class="line">    void success(@Nullable Object result);</span><br><span class="line"></span><br><span class="line">    void error(String errorCode, @Nullable String errorMessage, @Nullable Object errorDetails);</span><br><span class="line"></span><br><span class="line">    void notImplemented();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onMethodCall 响应调用的函数，并提供函数的返回值 Result。</p>
<h3 id="StreamHandler"><a href="#StreamHandler" class="headerlink" title="StreamHandler"></a>StreamHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface StreamHandler &#123;</span><br><span class="line"></span><br><span class="line">    void onListen(Object arguments, EventSink events);</span><br><span class="line"></span><br><span class="line">    void onCancel(Object arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface EventSink &#123;</span><br><span class="line"></span><br><span class="line">    void success(Object event);</span><br><span class="line"></span><br><span class="line">    void error(String errorCode, String errorMessage, Object errorDetails);</span><br><span class="line"></span><br><span class="line">    void endOfStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onListen 开启监听并发送数据，onCancel 取消监听。</p>
<h2 id="消息传递过程"><a href="#消息传递过程" class="headerlink" title="消息传递过程"></a>消息传递过程</h2><p>分析 Platform Channel 一个消息的完整调用路径：</p>
<h3 id="native-gt-dart"><a href="#native-gt-dart" class="headerlink" title="native -&gt; dart"></a>native -&gt; dart</h3><blockquote>
<p>从 DartMessenger 的 send 方法开始，<br>Java 通过 JNI 、iOS 直接调用 C/C++代码，<br>把消息通过 dispatchPlatformMessage 方法传递到 engine 层的 PlatformView 中，<br>然后分别经过 engine 、RuntimeController 最后调用 window 的 dispatchPlatformMessage 方法。<br>window 会自增一个 response_id 并创建一个 response 保存在 pending_responses_ 队列中，通过 tonic 库中的 DartInvokeField 方法调用 Dart 端的 _dispatchPlatformMessage，<br>完成了一个消息从 native 到 dart 的传递，<br>dart 端调用 window 的 onPlatformMessage 方法，<br>通过 channel name 匹配出已经注册好的 handler ，<br>执行后 通过 window 的 <em>respondToPlatformMessage 方法回调到 engine 层的 RespondToPlatformMessage 方法。<br>engine 根据 response_id 在 pending_responses</em> 取出对应的 response 执行 Complete 方法把结果返回给 Native 端，<br>Native 端在 DartMessenger 中的 handlePlatformMessageResponse 方法中处理具体返回的结果，完成了一整个的消息传递过程。</p>
</blockquote>
<h3 id="dart-gt-native"><a href="#dart-gt-native" class="headerlink" title="dart -&gt; native"></a>dart -&gt; native</h3><p>完整的过程跟 native 到 dart 的逻辑基本一致，除了一些函数调用上的差别，文字描述比较费力，这边是简单的做了一个图比较直观的看到整个消息的具体流向。</p>
<p><img src="../images/6.jpeg"></p>
<h1 id="Flutter-Support-Native"><a href="#Flutter-Support-Native" class="headerlink" title="Flutter Support Native"></a>Flutter Support Native</h1><p>在整个 Platform Channel 的实现细节梳理的过程中，我们不仅学习了一个数据通信的完整架构，同时也看到了大量的多种语言之间的相互调用。消息可以在不同的语言中自由的流转，主要是各种语言都实现了到 C/C++的函数调用的框架，Java 和 OC 已经有很成熟的支持 Native 的方案，Dart 也提供对 C/C++ 代码的调用的技术，具体的用法如下：</p>
<h2 id="Dart-调用-C-C-代码"><a href="#Dart-调用-C-C-代码" class="headerlink" title="Dart 调用 C/C++ 代码"></a>Dart 调用 C/C++ 代码</h2><p>Dart 对 C/C++ 的支持目前还并不完善，社区中吐槽 Dart 对 Native 支持进展缓慢的帖子很多，主要的嘈点是目前官方对于 Native 的支持文章 <a target="_blank" rel="noopener" href="https://dart.dev/server/c-interop-native-extensions">Native extensions for the standalone Dart VM</a> 还是 12 年 5 月份撰写的, 笔者也是根据这篇文章的指南调通了 Dart 对 C++ 的调用。在C++中实现了一个简单的加法运算，打包成 lib 提供给 Dart 调用。部分主要代码如下，完整工程可以在  <a target="_blank" rel="noopener" href="https://github.com/flutterboom/flutter-triple-sample/tree/master/dart-native-test">Github</a> 上查看，欢迎 Star 。</p>
<h3 id="native-plus-cc"><a href="#native-plus-cc" class="headerlink" title="native_plus.cc"></a>native_plus.cc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;第一次调用给定名称的本地函数时，将本地函数的 Dart 名称解析为 C 函数指针。</span><br><span class="line">Dart_NativeFunction ResolveName(Dart_Handle name,</span><br><span class="line">                                int argc,</span><br><span class="line">                                bool* auto_setup_scope);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在 lib 被加载时被调用。</span><br><span class="line">DART_EXPORT Dart_Handle native_plus_Init(Dart_Handle parent_library) ；</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现了一个加法运算</span><br><span class="line">void NativePlus(Dart_NativeArguments args) &#123;</span><br><span class="line">    Dart_EnterScope();</span><br><span class="line">    int64_t result &#x3D; 0;</span><br><span class="line">    Dart_Handle plus_a &#x3D; HandleError(Dart_GetNativeArgument(args, 0));</span><br><span class="line">    Dart_Handle plus_b &#x3D; HandleError(Dart_GetNativeArgument(args, 1));</span><br><span class="line">    if (Dart_IsInteger(plus_a) &amp;&amp; Dart_IsInteger(plus_b)) &#123;</span><br><span class="line">        int64_t a,b;</span><br><span class="line">        HandleError(Dart_IntegerToInt64(plus_a, &amp;a));</span><br><span class="line">        HandleError(Dart_IntegerToInt64(plus_b, &amp;b));</span><br><span class="line">        result &#x3D; a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    Dart_SetReturnValue(args, HandleError(Dart_NewInteger(result)));</span><br><span class="line">    Dart_ExitScope();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注册的方法列表</span><br><span class="line">FunctionLookup function_list[] &#x3D; &#123;</span><br><span class="line">    &#123;&quot;NativePlus&quot;, NativePlus&#125;,</span><br><span class="line">    &#123;NULL, NULL&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>C++代码可以根据不同平台 build 对应的链接库，我这边测试了在 MacOS上的导出，具体步骤如下：</p>
<blockquote>
<p> 使用 Xcode 创建本地扩展 dylib 项目：<br> 1、选择新建类型：File -&gt; New -&gt; Project -&gt; macOS -&gt; Library<br> 2、填写项目选项：<br>    -  Project Name：native_plus<br>    -  Framework：None(Plain C/C++ Library)<br>    -  Type：Dynamic<br> 3、添加 native_plus.cc 文件到项目中。<br> 4、在 Build Settings 中进行以下更改，在对话框中选择 Build 选项卡和 All Configurations ：<br>    - 在 Linking 部分， Other Linker Flags 项中，增加 -undefined dynamic_lookup 。<br>    - 在 Search Paths 部分， Header Search Paths 项中，增加 dart_api.h 文件路径，在文件位于已下载的 SDK 或 Dart 仓库中。<br>    - 在 Preprocessing 部分， Preprocessor Macros 项中，增加 DART_SHARED_LIB=1 。<br> 5、Build。</p>
</blockquote>
<h3 id="test-native-plus-dart"><a href="#test-native-plus-dart" class="headerlink" title="test_native_plus.dart"></a>test_native_plus.dart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;导入本地库，将 Build 生成的 libnative_plus.dylib 放置在同目录下</span><br><span class="line">import &#39;dart-ext:native_plus&#39;;</span><br><span class="line">&#x2F;&#x2F;用 Native 修饰本地库的函数</span><br><span class="line">int nativePlus(int a, int b) native &quot;NativePlus&quot;;</span><br><span class="line">void main() &#123;</span><br><span class="line">  print(nativePlus(3, 5));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还可以使用 [C &amp; C++ interop using FFI] (<a target="_blank" rel="noopener" href="https://dart.dev/server/c-interop">https://dart.dev/server/c-interop</a>) 对已经开发好的 C/C++ 链接库直接调用。</p>
<h1 id="Tonic"><a href="#Tonic" class="headerlink" title="Tonic"></a>Tonic</h1><p>Dart 对 Native 的支持目前还不是很完善，Flutter 团队目前开发的 Tonic 库很好的去支持 Dart 与 C/C++ 代码的相互调用。Tonic 的代码仓库地址在<a target="_blank" rel="noopener" href="https://fuchsia.googlesource.com/tonic">这里</a>。<br>A collection of C++ utilities for working with the DartVM API. 通过 Tonic 可以完整实现 Dart 与 C++ 之间的代码交互。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细梳理了 Platform Channel 完整的实现细节，最大的收获是对数据通信整体架构的设计和 Dart 与 C/C++ 之间代码的相互调用实现。行文比较仓促，作为一个 Android Coder ，部分案例也是基于 Android 的角度分析代码，可能对于 iOS 同学有一些不太友好，还望海涵。文中涉及到的任何内容，欢迎大家留言讨论。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:08:07.000Z" title="2020-12-19T11:08:07.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:12:04.802Z" title="2020-12-19T11:12:04.802Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/Maven-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">Maven 入门笔记</a></h1><div class="content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>后端开发领域非常庞大，知识体系涉及非常广泛，作为一个安卓转后端开发的新人，需要学习的内容非常多，像数据库、缓存、消息队列、微服务架构、网络通信、RPC、JAVA 语言等等。而学习一个领域最好的方式就是把这块内容整理消化，成为自己知识图谱中的一部分。未来计划是将这些领域的基础知识点都能归纳总结，今天就迈出了第一步，将就 JAVA 开发中非常基础也很重要的构建工具 - Maven 做一些整理归纳，一方面留给自己勘查校验使用，另一方面也希望对 JAVA 新手有一些借鉴意义。</p>
<h3 id="1、Maven-是什么？"><a href="#1、Maven-是什么？" class="headerlink" title="1、Maven 是什么？"></a>1、Maven 是什么？</h3><p>对于一个安卓开发的同学来说，Maven 可能更多的意味着一个 Maven 仓库，用来管理第三方 Library 的生成物，实际上 Maven 是一个主要用于 Java 项目的构建管理工具。</p>
<blockquote>
<p>We wanted a standard way to build the projects, a clear definition of what the project consisted of, an easy way to publish project information and a way to share JARs across several projects.</p>
</blockquote>
<p>从官网的介绍中我们大概可以看到 Maven 包含以下几个主要的功能：</p>
<ul>
<li>标准的构建工具</li>
<li>清晰的项目定义</li>
<li>便易的项目发布</li>
<li>轻松的依赖管理</li>
</ul>
<h3 id="2、两个重要配置文件"><a href="#2、两个重要配置文件" class="headerlink" title="2、两个重要配置文件"></a>2、两个重要配置文件</h3><h4 id="2-1-settings-xml"><a href="#2-1-settings-xml" class="headerlink" title="2.1 settings.xml"></a>2.1 settings.xml</h4><p>对于 Maven 的全局配置是通过 settings.xml 文件来进行管理的，settings 文件的配置包含两个作用域（ 用户域会高于版本域，当两个路径都有配置且存在相同配置项的时候，用户域优先 ）:</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>位置</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td>用户级</td>
<td>%USER_HOME%/.m2/settings.xml</td>
<td>当前用户</td>
</tr>
<tr>
<td>版本级</td>
<td>%M2_HOME%/conf/settings.xml</td>
<td>当前版本</td>
</tr>
</tbody></table>
<p>settings.xml 主要配置如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>localRepository</td>
<td>本地仓库地址，默认是${user.home}/.m2/repository</td>
</tr>
<tr>
<td>interactiveMode</td>
<td>是否交互式创建Maven项目，默认true。</td>
</tr>
<tr>
<td>usePluginRegistry</td>
<td>是否需要使用plugin-registry.xml文件来管理插件版本，默认false。</td>
</tr>
<tr>
<td>offline</td>
<td>是否是离线模式下构建，默认false。</td>
</tr>
<tr>
<td>proxies</td>
<td>代理配置，科学上网</td>
</tr>
<tr>
<td><strong><em>servers</em></strong></td>
<td>服务认证，配合pom.xml中distributionManagement设置，用于上传私服的用户验证</td>
</tr>
<tr>
<td>mirrors</td>
<td>仓库镜像配置</td>
</tr>
<tr>
<td><strong><em>profiles</em></strong></td>
<td>多环境配置，设置环境参数</td>
</tr>
<tr>
<td>activeProfiles</td>
<td>默认激活的环境配置</td>
</tr>
<tr>
<td>pluginGroups</td>
<td>默认的pluginGroupId</td>
</tr>
</tbody></table>
<h4 id="2-2-POM-xml"><a href="#2-2-POM-xml" class="headerlink" title="2.2 POM.xml"></a>2.2 POM.xml</h4><p>pom 的全称是项目对象模块（Project Object Model），它是一个 Maven 项目的核心，通过 xml 语言定义了一个项目的基本信息、依赖信息、构建参数等等。主要的配置参数如下：</p>
<h5 id="2-2-1【基础信息】"><a href="#2-2-1【基础信息】" class="headerlink" title="2.2.1【基础信息】"></a>2.2.1【基础信息】</h5><p>指定了项目在 Maven 仓库中的唯一坐标：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>groupId</td>
<td>项目名称</td>
</tr>
<tr>
<td>artifactId</td>
<td>项目中细分的模块名称</td>
</tr>
<tr>
<td>version</td>
<td>版本号</td>
</tr>
<tr>
<td>packaging</td>
<td>打包方式，包含jar、pom、war等</td>
</tr>
</tbody></table>
<h5 id="2-2-2【依赖信息】"><a href="#2-2-2【依赖信息】" class="headerlink" title="2.2.2【依赖信息】"></a>2.2.2【依赖信息】</h5><p>通过 dependencies 标签描述了项目依赖的其他项目，其中 groupId, artifactId, version 是必须的，唯一指定了一个项目的坐标，另外一个关键的参数是 scope ，指定了依赖的作用范围：</p>
<table>
<thead>
<tr>
<th>scope</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>默认值，一个比较强的依赖，参与编译、测试、打包</td>
</tr>
<tr>
<td>provided</td>
<td>参与编译，不参与打包</td>
</tr>
<tr>
<td>runtime</td>
<td>不参与编译，直接入包</td>
</tr>
<tr>
<td>test</td>
<td>只在测试时有效</td>
</tr>
</tbody></table>
<p>通过 dependencyManagement 标签可以统一管理依赖的版本号，一般的，在父 POM 中的 dependencyManagement 声明用到的依赖及其版本，则可以在子 POM 中只引用 groupId 和 artifactId 并继承 version ，达到统一管理的目的。</p>
<h5 id="2-2-3【聚合继承】"><a href="#2-2-3【聚合继承】" class="headerlink" title="2.2.3【聚合继承】"></a>2.2.3【聚合继承】</h5><p>现在的大型项目基本上都采用了多模块的架构方式，而 Maven 通过聚合继承了的方式很好的解决了多模块构建的问题。</p>
<p>在 modules 标签中添加管理的子模块，Maven 在构建的就会根据模块之间的依赖关系按照顺序依次构建，避免了多模块开发中每个模块都需要单独构建的浪费。</p>
<p>在 parent 标签中指定了父 POM 的地址，实际上子 POM 通过继承获取的绝大部分父 POM 的配置，Maven 通过这种继承的方式，大大简化了子 POM 的配置，同时将一些公共的配置放在父 POM 中管理，更有利于维护大型项目的规范性。如果没有指定 parent ，则默认系统的 pom.xml 这个超级 POM 作为父 POM， 实际上超级 POM 已经定义了很多默认参数作为最佳实践，简化了 POM 的配置。</p>
<h5 id="2-2-4【构建参数】"><a href="#2-2-4【构建参数】" class="headerlink" title="2.2.4【构建参数】"></a>2.2.4【构建参数】</h5><p>通过 build 元素描述构建参数，pom.xml 中有两种 build 配置，一种是在 project 根标签下，称之为 Project Build，一种是在 profile 标签下，称之为 Profile Build，主要用于多环境配置中的构建配置，在我们的项目中使用比较少，下面主要介绍 Project Build 的主要配置：</p>
<h5 id="2-2-4-1-基础信息"><a href="#2-2-4-1-基础信息" class="headerlink" title="2.2.4.1 基础信息"></a>2.2.4.1 基础信息</h5><p>主要描述跟构建相关的信息，比如源码路径、目标文件名、目标文件路径、</p>
<ul>
<li>defaultGoal,执行构建时默认的goal或phase</li>
<li>directory, build 目标文件的存放目录，默认在 {basedir}/target 目录</li>
<li>outputDirectory, build 源码目标文件的存放目录，默认在 {basedir}/target/classes 目录</li>
<li>sourceDirectory, 源码目录</li>
<li>finalName, build 目标文件的文件名，默认情况下为 {artifactId}-{version}</li>
</ul>
<h5 id="2-2-4-2-resources-标签"><a href="#2-2-4-2-resources-标签" class="headerlink" title="2.2.4.2 resources 标签"></a>2.2.4.2 resources 标签</h5><p>描述了项目中运行或测试相关的所有资源参数</p>
<h5 id="2-2-4-3-plugins-标签"><a href="#2-2-4-3-plugins-标签" class="headerlink" title="2.2.4.3 plugins 标签"></a>2.2.4.3 plugins 标签</h5><p>Maven 的每一个构建任务的实际实现都是通过 plugin 完成的，Maven 提供了一个可执行的环境，具体的构建任务是在各种 plugin 中定义的，比如用于编译的 compile 插件，用户打包的 jar 插件等等。Maven 已经提供了大量默认 plugin 涵盖项目的编译、测试、打包、部署等方方面面。目前 Maven 官方有两个插件列表，第一个列表的 GroupId 为 <a target="_blank" rel="noopener" href="http://maven.apache.org/plugins/index.html">org.apache.maven.plugins</a>，这里的插件最为成熟 。第二个列表的 GroupId 为 <a target="_blank" rel="noopener" href="http://mojo.codehaus.org/plugins.html">org.codehaus.mojo</a>，这里的插件没有那么核心，但也有不少十分有用。项目中经常用到的一些插件包括：</p>
<ul>
<li>maven-clean-plugin</li>
<li>maven-compiler-plugin</li>
<li>maven-deploy-plugin</li>
<li>maven-install-plugin</li>
<li>maven-antrun-plugin  </li>
<li>maven-archetype-plugin</li>
<li>maven-assembly-plugin</li>
<li>maven-dependency-plugin</li>
<li>maven-enforcer-plugin</li>
<li>maven-help-plugin</li>
<li>maven-release-plugin</li>
<li>maven-resources-plugin</li>
<li>maven-surefire-plugin</li>
<li>build-helper-maven-plugin</li>
<li>exec-maven-plugin</li>
<li>jetty-maven-plugin</li>
<li>versions-maven-plugin</li>
</ul>
<h5 id="2-2-5【环境参数】"><a href="#2-2-5【环境参数】" class="headerlink" title="2.2.5【环境参数】"></a>2.2.5【环境参数】</h5><p>通过 scm 标签配置项目的代码仓库配置，这个一般在公司项目中很少使用。<br>通过 distributionManagement 标签，可以指定 Maven 上传的地址，一般会定义 release 和 snapshot 两个仓库，同时配合 Setting.xml 中 servers 的用户登录配置，完成私仓的上传校验。<br>通过 profiles 标签定义了多环境下的参数配置，一般用于区分开发环境、测试环境和线上环境等。</p>
<h3 id="3、生命周期"><a href="#3、生命周期" class="headerlink" title="3、生命周期"></a>3、生命周期</h3><h4 id="3-1-深入理解-lifecycle、phase、goal、plugin"><a href="#3-1-深入理解-lifecycle、phase、goal、plugin" class="headerlink" title="3.1 深入理解 lifecycle、phase、goal、plugin"></a>3.1 深入理解 lifecycle、phase、goal、plugin</h4><p>Maven 抽象了一个生命周期(lifecycle)的概念，把一个Java项目的构建过程抽象为三种场景：清除(clean)、构建(default)、部署(site)。生命周期是构建过程的统一和抽象，没有具体执行任务。一个场景的生命周期中被划分为多个阶段(phase),而每个阶段又包含着一个或者多个目标(goal)，而每个目标才是真正要实现的操作，这部分实现是在插件(plugin)中完成的。</p>
<p>实际上 Maven 打造了两套系统，一个是通过定义【生命周期】、【阶段】、【目标】这三层结构创建了一个可执行的环境，将 Java 项目中的不同场景进行了覆盖。另一个是通过定义一套【插件】系统，去具体完成一些构建目标。然后通过一种绑定机制，非常有效的将插件运行在 Maven 的执行环境中。实际上看这两套系统的实现非常契合我们常见的模版模式的一种设计方式，也让我们的插件系统有了更好的拓展性。</p>
<p>将 Maven 插件目标和生命周期阶段进行绑定可以在执行某一阶段的构建时运行插件的目标，目前 Maven 已经提供了以下一些内置的标准绑定：</p>
<table>
    <tr>
        <th>生命周期</th>
        <th>阶段</th>
        <th>插件目标</th>
    </tr>
    <tr>
        <td>clean</td> 
        <td>clean</td> 
          <td>maven-clean-plugin:clean</td>   
    </tr>
    </tr>
    <tr>
        <td rowspan="8">default</td> 
         <td>process-resources</td> 
        <td>maven-resources-plugin:resources</td>  
    </tr>
    <tr>
        <td>compile</td> 
          <td>maven-compiler-plugin:compile</td>   
    </tr>
    <tr>
        <td>process-test-resources</td> 
         <td>maven-resources-plugin:testResources</td>   
    </tr>
    <tr>
        <td>test-compile</td> 
         <td>maven-compiler-plugin:testCompile</td>   
    </tr>
    <tr>
        <td>test</td> 
         <td>maven-surefire-plugin:test</td>   
    </tr>
    <tr>
        <td>package</td> 
         <td>maven-jar-plugin:jar</td>   
    </tr>
    <tr>
        <td>install</td> 
         <td>maven-install-plugin:install</td>   
    </tr>
    <tr>
        <td>deploy</td> 
         <td>maven-deploy-plugin:deploy</td>   
    </tr>
    <tr>
        <td rowspan="2">site</td> 
         <td>site</td> 
        <td>maven-site-plugin:site</td>  
    </tr>
    <tr>
        <td>site-deploy</td> 
          <td>maven-site-plugin:deploy</td>   
    </tr>
</table>

<p>除了内置的绑定关系外，Maven还提供了一种自定义的绑定方式，不过这里有一点局限的是绑定的阶段必须是 Maven 已经预置的阶段(phase)，可以在 POM 的 executions 标签中进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-source-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;attach-sources&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;jar-no-fork&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">    &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-2、mvn-命令行"><a href="#3-2、mvn-命令行" class="headerlink" title="3.2、mvn 命令行"></a>3.2、mvn 命令行</h4><p>Maven 提供了 mvn 的命令行工具，用于项目的构建执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn [options] [&lt;goal(s)&gt;] [&lt;phase(s)&gt;]</span><br></pre></td></tr></table></figure>
<p>mvn 实际上提供了两种构建的方式，一种是执行指定的goal(s)，一种是执行phase(s)。不同的是，执行 phase 的时候会先执行依赖的 phase ，而执行 goal 仅仅执行自己，需要已经存在前置依赖的环境，否则失败。两种调用方式以 install 举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn install  ( phase 方式)</span><br><span class="line">mvn org.apache.maven.plugins:maven-install-plugin:2.4:install ( goal 方式)</span><br></pre></td></tr></table></figure>
<p>前面我们提到，我们把插件目标和生命周期阶段绑定之后，实际上我们执行 mvn [&lt;phase(s)&gt;] 就是执行一个有序的 goals 列表。当然我们看到，上面这种执行 goal 的方式命令太长，参数比较繁琐，实际上它有几个简化的版本：</p>
<p>首先版本号如果没有特殊指定 Maven 会到对应插件的 <a target="_blank" rel="noopener" href="http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-install-plugin/maven-metadata.xml">maven-metadata.xml</a> 文件中找到 release 版本进行使用，所以命令可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn org.apache.maven.plugins:maven-install-plugin:install</span><br></pre></td></tr></table></figure>
<p>另外 Maven 默认以 org.apache.maven.plugins 作为 groupId ，我们可以在 settings.xml 文件中通过 pluginGroups 标签指定默认的 groupId ，所以我们可以省略一长串的 groupId ，去掉 groupId 之后，我们还可以使用 plugin 的缩略名，这个缩略名定义在 plugins 仓库的 <a target="_blank" rel="noopener" href="http://repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-metadata.xml">maven-metadata.xml</a> 文件中。 maven-install-plugin 插件的缩略名为 install ，所以我们的命令最终可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install</span><br></pre></td></tr></table></figure>

<h3 id="4、依赖管理"><a href="#4、依赖管理" class="headerlink" title="4、依赖管理"></a>4、依赖管理</h3><h4 id="4-1-依赖传递"><a href="#4-1-依赖传递" class="headerlink" title="4.1 依赖传递"></a>4.1 依赖传递</h4><p>Maven 提供了一种隐性依赖的方式将间接依赖的三方库像直接依赖一样，举例来说，项目 A 依赖了项目 B ，项目 B 依赖了项目 C ，那项目 A 就像直接依赖了项目 C 一样使用项目 C 对外暴露的功能。不过在一个大型的项目管理中，错综复杂的依赖关系会导致依赖传递过程中出现的各种依赖冲突。一般地，我们可以通过 dependencyManagement 在根项目中指定项目的版本，如果没有指定，Maven 将按照默认提供的依赖仲裁法案对于版本号不一致的项目进行科学仲裁，这跟 Gradle 中默认选择最高版本的做法不太一致，这种仲裁有两个原则：<br>一、就近原则，根据项目依赖深度选择最近依赖的版本；</p>
<pre><code>A -&gt; B -&gt; C 2.0
A -&gt; C 1.0
通过就近原则，最终 A 依赖 C 的是 1.0 的版本。</code></pre>
<p>二、优先声明原则，如果路径深度一致，则选择最先声明的版本。</p>
<pre><code>A -&gt; B -&gt; C 2.0
A -&gt; D -&gt; C 1.0
通过优先声明原则，最终 A 依赖 C 的是 2.0 的版本。</code></pre>
<p>另外，通过 exclusion 标签可以把不需要的项目版本排除依赖，直接指定特定的版本来解决依赖冲突。</p>
<h4 id="4-2-依赖带来的问题"><a href="#4-2-依赖带来的问题" class="headerlink" title="4.2 依赖带来的问题"></a>4.2 依赖带来的问题</h4><ul>
<li><p>java.lang.ClassNotFoundException</p>
</li>
<li><p>java.lang.NoSuchMethodException</p>
</li>
</ul>
<p>一般的，当我们遇到这两类错误的时候，第一反应就是引用的jar包版本不对，一方面有可能是使用的三方jar包与线上环境不一致，导致运行时无法找到类或者方法而抛错，另一方面，可能更常见的是由于多方依赖导致的依赖冲突，由于 Maven 仲裁只能选择一个版本，导致另外一个版本所使用的API存在 NotFound 的风险。</p>
<h4 id="4-3-冲突解决"><a href="#4-3-冲突解决" class="headerlink" title="4.3 冲突解决"></a>4.3 冲突解决</h4><p>在 Intellij idea 上可以非常方便的查看一个项目的依赖关系，总体来说有以下几个方式：</p>
<p>1）通过查看 pom 文件的 Diagrams ，在 IDE 上会生成项目的依赖关系 UML 图，图中不仅以树状的结构清晰的展示了项目直接依赖和间接依赖的所有项目，同时对于有依赖版本冲突的项目通过红线标注，可以很方便的使用 exclusion 排除进行冲突解决。</p>
<p><img src="../images/3.jpeg"></p>
<p>2）安装 Maven Helper 插件，可以对于每个 pom.xml 文件提供 Dependency Analyzer 功能，对于版本冲突的依赖会高亮显示，右击 Exclude 可排除依赖。</p>
<p><img src="../images/4.jpeg"></p>
<p>3）IDE 中 Maven 侧边栏中通过层级结构清晰的显示了依赖关系，对于冲突的版本通过灰色进行了说明。</p>
<p><img src="../images/5.jpeg"></p>
<p>4） mvn dependency:tree 命令可以打印出当前项目的依赖树，不过总体上没有以上三种直观。</p>
<h3 id="5、自定义插件"><a href="#5、自定义插件" class="headerlink" title="5、自定义插件"></a>5、自定义插件</h3><p>除系统提供的 Maven 插件外，我们还可以根据自己业务的特定需求，自定义符合自己需要的 Maven 插件，比较熟悉的像 MyBatis 插件，就是帮助我们自动生成数据库相关的交互代码，通过定义插件，一方面可以简化我们某些特定的代码编写，另外一方面也可以将我们的某部分代码进行规范，减少手写误操作引入的bug 。</p>
<p>自定义插件的方式非常简单，主要是继承 AbstractMojo 类并实现 execute 方法，这方面的资料在网上也比较多，最主要的是大家应该知道在什么场景下需要实现自定义的插件。这里就我们现实中的一个需求，编写了一个简单的插件来说明自定义插件的意义。</p>
<p>代码地址在: <a target="_blank" rel="noopener" href="https://github.com/pandavickey/panda-maven">Github:panda-maven</a></p>
<p>这个插件的使用场景是对我们需要的 service 对外暴露生成一个 interface ，因为在我们公司提供的 SOA 服务中，是以 interface 进行注册的，如果我们想对一些特定的 service 对外暴露，就需要手写一些 interface 及 impl，这些非常机械的工作当然是可以交给 Maven 插件来完成的。插件比较简单，仅仅作为自己学习 Maven 练手使用，如果大家有类似的需求，可以在此基础上进行优化完善。</p>
<h3 id="6、结语：约定优于配置"><a href="#6、结语：约定优于配置" class="headerlink" title="6、结语：约定优于配置"></a>6、结语：<em>约定优于配置</em></h3><p>实际上，Maven 一直提倡的是简约风。将大家约定俗成的规范设置为默认配置，提供最佳实践作为 Maven 使用规范，使得我们在日常的使用过程中只需要对 Maven 进行简单的配置就可以完成绝大部分的工作。我们应该谨记 Maven 的这条经验，尽量使用默认提供的配置选项，减少奇奇怪怪的特定配置。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:06:25.000Z" title="2020-12-19T11:06:25.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:06:44.221Z" title="2020-12-19T11:06:44.221Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/Android-Gradle-Plugin%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Android Gradle Plugin源码解析</a></h1><div class="content"><p>笔者最近在做公司项目的模块化重构，做的过程中一直在思考以下几个问题:</p>
<ul>
<li>一个apk文件和一个aar文件有什么区别？</li>
<li>什么样的工程会导出一个apk，什么样的工程可以导出aar?</li>
<li>一个apk的诞生伴随着哪些配置的过程，aar呢？</li>
<li>他们俩之间可以快速的进行交换吗？</li>
</ul>
<p>以上的这些疑问都在Google大大给我们开发的两个plugin中得到答案:</p>
<ul>
<li>com.android.application</li>
<li>com.android.library</li>
</ul>
<p>这是我们开发安卓应用时最常用的两个plugin，作为一个Android开发者，怎么可能不对它的实现不感兴趣呢，所以接下来我将用两到三个博客的内容，谈一谈读Android Gradle Plugin源码的一些心得。今天主要讲一些基础的部分。</p>
<h1 id="源码下载方式"><a href="#源码下载方式" class="headerlink" title="源码下载方式"></a>源码下载方式</h1><p>Android Gradle Plugin 一个版本的源码大概有30多个G，如果你的磁盘资源充足，可以使用repo的方式下载到本地，下面是2.3.0分支的一个示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gradle_2.3.0</span><br><span class="line">$ cd gradle_2.3.0</span><br><span class="line">$ repo init -u https:&#x2F;&#x2F;android.googlesource.com&#x2F;platform&#x2F;manifest -b gradle_2.3.0</span><br><span class="line">$ repo sync</span><br></pre></td></tr></table></figure>
<p>如果你没有翻墙的工具，可以使用国内的一些镜像:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华大学开源软件镜像站</a></li>
<li><a target="_blank" rel="noopener" href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp">中国科技大学开源软件镜像站</a></li>
</ul>
<p>repo的初始化可以参照 Google 教程 <a target="_blank" rel="noopener" href="https://source.android.com/source/downloading.html">https://source.android.com/source/downloading.html</a></p>
<p>下载后的源码用IntelliJ IDEA打开tools的base路径，目录结构如下:<br><img src="https://user-gold-cdn.xitu.io/2018/8/29/1658474a322708af?w=934&h=1384&f=jpeg&s=67768" alt="项目结构"></p>
<p>主要代码在红框内的三个module中。在看Android Gradle Plugin的源码之前，我们先简单的看一下一个自定义的Gradle Plugin是如何实现的。</p>
<h1 id="Gradle-plugin简介"><a href="#Gradle-plugin简介" class="headerlink" title="Gradle plugin简介"></a>Gradle plugin简介</h1><p>关于自定义一个 Gradle Plugin 的教程很多，我们简单的做一个说明。使用 gradle init 命令可以在当前目录下新建一个简单的gradle工程，目录结构如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/29/1658474a34e992ee?w=384&h=310&f=jpeg&s=10951" alt="gradle工程"></p>
<p>这是一个基于Gradle Wrapper的多工程Gradle项目。在settings.gradle中可以配置子项目的路径，像我们在Android项目中经常配置的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &#39;:app&#39;</span><br><span class="line">include &#39;:lib&#39;</span><br></pre></td></tr></table></figure>
<p>说到这里可以多说一句在模块化开发中的经验，我们可以通过指定subproject的路径的方式，可以将本地任何路径下的代码导入工程中来，方便我们进行本地调试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &#39;:lib&#39;</span><br><span class="line">project(&#39;:lib&#39;).projectDir &#x3D; new File(&#39;xx&#x2F;xx&#x2F;xx&#x2F;lib&#39;)</span><br></pre></td></tr></table></figure>
<p>在rootproject的build.gradle文件中创建一个最简单的gradle plugin:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class GreetingPluginExtension &#123;</span><br><span class="line">    String message</span><br><span class="line">    String greeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        def extension &#x3D; project.extensions.create(&#39;greeting&#39;, GreetingPluginExtension)</span><br><span class="line">        project.task(&#39;hello&#39;) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println &quot;$&#123;extension.message&#125; from $&#123;extension.greeter&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message &#x3D; &#39;Hi&#39;</span><br><span class="line">    greeter &#x3D; &#39;Gradle&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，我们定义了一个GreetingPlugin，他新增了一个名为 ‘hello’ 的task，在终端输出一行信息，这个信息可以通过 GreetingPluginExtension 进行配置，我们执行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gradlew hello</span><br><span class="line">Starting a Gradle Daemon (subsequent builds will be faster)</span><br><span class="line">Parallel execution with configuration on demand is an incubating feature.</span><br><span class="line">:hello</span><br><span class="line">Hi from Gradle</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 4.0 secs</span><br></pre></td></tr></table></figure>
<p>其实也可以看出自定义一个plugin主要就是新增 <strong><em>Task</em></strong> 及所需参数进行配置的 <strong><em>Extension</em></strong>。Android Gradle Plugin定义了很多task，其中我们最常用的包括 <strong>clean</strong> <strong>build</strong> <strong>assemble</strong> 等,还有更多这些task运行时依赖的task，涉及到安卓编译打包的各个方面，我们在下一个博客中再具体阐述。今天主要Android Plugin的Extension的部分实现，这也是我们日常配置一个Android工程最主要的工作。</p>
<h1 id="Extension机制"><a href="#Extension机制" class="headerlink" title="Extension机制"></a>Extension机制</h1><p>如何理解 Gradle 的 Extension，这涉及到Groovy的闭包委托特性。Groovy的闭包有this、owner、delegate三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。有关闭包的详情可以查看 <a target="_blank" rel="noopener" href="http://groovy-lang.org/closures.html">Groovy Closures</a>。利用Groovy的闭包委托特性，我们可以简单的实现Extension:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String personName &#x3D; &#39;李四&#39;  </span><br><span class="line">    int personAge &#x3D; 18</span><br><span class="line">    def printPerson()&#123;</span><br><span class="line">        println &quot;name is $&#123;personName&#125;,age is $&#123;personAge&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">def person(Closure&lt;Person&gt; closure)&#123;</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    closure.delegate &#x3D; p    &#x2F;&#x2F;委托模式优先</span><br><span class="line">    closure.setResolveStrategy(Closure.DELEGATE_FIRST);</span><br><span class="line">    return closure</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def closure &#x3D; person &#123;</span><br><span class="line">    personName &#x3D; &#39;张三&#39;</span><br><span class="line">    personAge &#x3D; 20</span><br><span class="line">    printPerson()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task configClosure &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        closure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义一个Person对象，然后定义一个person的方法，它接受一个闭包作为参数，修改闭包委托模式优先，执行person方法，定义一个task执行这个闭包，运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;gradlew configClosure</span><br><span class="line">Parallel execution with configuration on demand is an incubating feature.</span><br><span class="line">:configClosure</span><br><span class="line">name is 张三,age is 20</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 0.981 secs</span><br></pre></td></tr></table></figure>
<p>Gradle中大量使用了Extension这一特性，引用gradle一句原话：</p>
<blockquote>
<p>Many Gradle objects are extension aware. This includes; projects, tasks, configurations, dependencies etc.</p>
</blockquote>
<p>安卓插件使用的Extension都继承自BaseExtension:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* &lt;ul&gt;</span><br><span class="line">* &lt;li&gt;Plugin &lt;code&gt;com.android.application&lt;&#x2F;code&gt; uses &#123;@link AppExtension&#125;</span><br><span class="line">* &lt;li&gt;Plugin &lt;code&gt;com.android.library&lt;&#x2F;code&gt; uses &#123;@link LibraryExtension&#125;</span><br><span class="line">* &lt;li&gt;Plugin &lt;code&gt;com.android.test&lt;&#x2F;code&gt; uses &#123;@link TestExtension&#125;</span><br><span class="line">* &lt;li&gt;Plugin &lt;code&gt;com.android.atom&lt;&#x2F;code&gt; uses &#123;@link AtomExtension&#125;</span><br><span class="line">* &lt;li&gt;Plugin &lt;code&gt;com.android.instantapp&lt;&#x2F;code&gt; uses &#123;@link InstantAppExtension&#125;</span><br><span class="line">* &lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>com.android.application插件使用的是AppExtension，com.android.library插件使用的是LibraryExtension。下面分别讲一下两个Extension的详细配置。</p>
<h1 id="AppExtension"><a href="#AppExtension" class="headerlink" title="AppExtension"></a>AppExtension</h1><p>以下是AppExtension的所有配置，我按照使用频率进行一个简单的介绍，第一行是官方对于属性的介绍，我会针对每个属性做一些使用上的说明。</p>
<h3 id="applicationVariants"><a href="#applicationVariants" class="headerlink" title="applicationVariants"></a>applicationVariants</h3><p>The list of Application variants. Since the collections is built after evaluation, it should be used with Gradle’s all iterator to process future items.</p>
<p>applicationVariants是AppExtension继承自BaseExtension唯一拓展的成员变量，它的参数类型是DefaultDomainObjectSet<ApplicationVariant>，这是不同buildType及Flavor的集合，<br>applicationVariants最常用的是它的all方法，例如一个简单的修改apk名字的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def buildTime() &#123;</span><br><span class="line">    return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))</span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">	applicationVariants.all &#123; variant -&gt;</span><br><span class="line">		variant.outputs.each &#123; output -&gt;</span><br><span class="line">			def outputFile &#x3D; output.outputFile</span><br><span class="line">			if (outputFile !&#x3D; null &amp;&amp; outputFile.name.endsWith(&#39;.apk&#39;)) &#123;</span><br><span class="line">				def fileName &#x3D; &quot;$&#123;variant.buildType.name&#125;-$&#123;variant.versionName&#125;-$&#123;buildTime()&#125;.apk&quot;</span><br><span class="line">				output.outputFile &#x3D; new File(output.outputFile.parent,fileName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h3><p>Required. Version of the build tools to use.</p>
<h3 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h3><p>Default config, shared by all flavors.</p>
<p>所有Flavor的默认设置，它是一个 ProductFlavor 对象，可以做以下设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">	applicationId	 &#39;**.**.**&#39; &#x2F;&#x2F;The application ID.</span><br><span class="line">	</span><br><span class="line">	applicationIdSuffix &#39;.two&#39; &#x2F;&#x2F;applicationId的后缀，可以用在想同时安装运行两个Flavor包的时候，比如同时安装debug包和Release包做一些对比。</span><br><span class="line"></span><br><span class="line">    minSdkVersion 14</span><br><span class="line"></span><br><span class="line">    targetSdkVersion 25</span><br><span class="line"></span><br><span class="line">    versionCode  1</span><br><span class="line"></span><br><span class="line">    versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">    versionNameSuffix &quot;.0&quot;  &#x2F;&#x2F; versionName后缀</span><br><span class="line">	</span><br><span class="line">	consumerProguardFiles &#39;proguard-rules.pro&#39; &#x2F;&#x2F;用于Library中，可以将混淆文件输出到aar中，供Application混淆时使用。</span><br><span class="line">	</span><br><span class="line">	dimension &#39;api&#39; &#x2F;&#x2F;给渠道一个分组加维度的概念，比如你现在有三个渠道包，分成免费和收费两种类型，可以添加一个dimension, 打渠道包的时候会自动打出6个包，而不需要添加6个渠道，详细的说明可见 https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;build&#x2F;build-variants.html#flavor-dimensions。</span><br><span class="line">	                     </span><br><span class="line">	externalNativeBuild &#123;   &#x2F;&#x2F;ndk的配置，AS2.2之后推荐切换到cmake的方式进行编译。</span><br><span class="line">        cmake &#123;</span><br><span class="line">        	  cppFlags &quot;-frtti -fexceptions&quot;</span><br><span class="line">              arguments &quot;-DANDROID_ARM_NEON&#x3D;TRUE&quot;</span><br><span class="line">        	  buildStagingDirectory &quot;.&#x2F;outputs&#x2F;cmake&quot;</span><br><span class="line">            path &quot;CMakeLists.txt&quot;</span><br><span class="line">            version &quot;3.7.1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ndkBuild &#123;</span><br><span class="line">            path &quot;Android.mk&quot;</span><br><span class="line">            buildStagingDirectory &quot;.&#x2F;outputs&#x2F;ndk-build&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;    &#x2F;&#x2F;注解的配置。</span><br><span class="line">                includeCompileClasspath true &#x2F;&#x2F;需要使用注解功能。</span><br><span class="line">                arguments &#x3D; [ eventBusIndex : &#39;org.greenrobot.eventbusperf.MyEventBusIndex&#39; ]   &#x2F;&#x2F;AbstractProcessor中可以读取到该参数。</span><br><span class="line">                classNames </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    manifestPlaceholders &#x3D; [key:&#39;value&#39;]     &#x2F;&#x2F;manifest占位符 定义参数给manifest调用，如不同的渠道id。</span><br><span class="line">	</span><br><span class="line">    multiDexEnabled true      &#x2F;&#x2F;开启 multiDex</span><br><span class="line"></span><br><span class="line">    multiDexKeepFile  file(&#39;multiDexKeep.txt&#39;)    &#x2F;&#x2F;手动拆包，将具体的类放在主DEX。</span><br><span class="line"></span><br><span class="line">    multiDexKeepProguard   file(&#39;multiDexKeep.pro&#39;)  &#x2F;&#x2F;支持Proguard语法，进行一些模糊匹配。</span><br><span class="line"></span><br><span class="line">    ndk &#123;</span><br><span class="line">        abiFilters &#39;x86&#39;, &#39;x86_64&#39;, &#39;armeabi&#39;   &#x2F;&#x2F;只保留特定的api输出到apk文件中。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#x2F;&#x2F;混淆文件的列表，如默认的android混淆文件及本地proguard文件，</span><br><span class="line">                                                                                      &#x2F;&#x2F;切记不要遗漏android混淆文件，否则会导致一些默认的安卓组件无法找到。</span><br><span class="line"></span><br><span class="line">    signingConfig &#123;</span><br><span class="line">            &#x2F;&#x2F;签名文件的路径</span><br><span class="line">            storeFile file(&#39;debug.keystore&#39;)</span><br><span class="line">            &#x2F;&#x2F;签名文件密码</span><br><span class="line">            storePassword &#39;android&#39;</span><br><span class="line">            &#x2F;&#x2F;别名</span><br><span class="line">            keyAlias &#39;androiddebygkey&#39;</span><br><span class="line">            &#x2F;&#x2F;key的密码</span><br><span class="line">            keyPassword &#39;android&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildConfigField(&#39;boolean&#39;,&#39;IS_RELEASE&#39;,&#39;false&#39;)   &#x2F;&#x2F;代码中可以通过BuildConfig.IS_RELEASE 调用。</span><br><span class="line"></span><br><span class="line">    resValue(&#39;string&#39;,&#39;appname&#39;,&#39;demo&#39;)  &#x2F;&#x2F;在res&#x2F;value 中添加&lt;string name&#x3D;&quot;appname&quot; translatable&#x3D;&quot;false&quot;&gt;demo&lt;&#x2F;string&gt;。</span><br><span class="line"></span><br><span class="line">    resConfigs &quot;cn&quot;, &quot;hdpi&quot;  &#x2F;&#x2F;指定特定资源，可以结合productFlavors实现不同渠道的最小的apk包。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h3><p>All product flavors used by this project.<br>渠道包的列表，可以覆盖defaultConfig的参数配置，形成自己的风味</p>
<h3 id="flavorDimensionList"><a href="#flavorDimensionList" class="headerlink" title="flavorDimensionList"></a>flavorDimensionList</h3><p>The names of flavor dimensions.<br>添加维度的定义，维度的使用上面defaultConfig已经有说明了。</p>
<h3 id="resourcePrefix"><a href="#resourcePrefix" class="headerlink" title="resourcePrefix"></a>resourcePrefix</h3><p>A prefix to be used when creating new resources. Used by Android Studio.<br>在模块化开发中比较重要，给每个模块指定一个特定的资源前缀，可以避免多模块使用相同的文件命名后合并冲突，在build.gradle中指定了这个配置后，AS会检查不合法的资源命名并报错。</p>
<h3 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h3><p>Build types used by this project.</p>
<p>buildType的列表，默认有release和debug，可以自己自定义不同的buildtype，相应的构建task name是 assemble+buildTypeName, buildType部分配置和defaultConfig相同，不同配置使用说明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">debug &#123;</span><br><span class="line"></span><br><span class="line">       applicationIdSuffix   &#39;.debug&#39;        &#x2F;&#x2F;同defaultConfig</span><br><span class="line"></span><br><span class="line">       versionNameSuffix &#39;.1&#39;     &#x2F;&#x2F;同defaultConfig</span><br><span class="line"></span><br><span class="line">       debuggable true  &#x2F;&#x2F;生成的apk是否可以调试 debug默认是true   release默认false</span><br><span class="line"></span><br><span class="line">       jniDebuggable true   &#x2F;&#x2F;是否可以调试NDK代码 使用lldb进行c和c++代码调试</span><br><span class="line"></span><br><span class="line">       crunchPngs   true  &#x2F;&#x2F;是否开启png优化，会对png图片做一次最优压缩，影响编译速度，debug默认是false   release默认true</span><br><span class="line"></span><br><span class="line">       embedMicroApp true  &#x2F;&#x2F;Android Wear的支持</span><br><span class="line"></span><br><span class="line">       minifyEnabled  true &#x2F;&#x2F;是否开启混淆</span><br><span class="line"></span><br><span class="line">       renderscriptDebuggable false   &#x2F;&#x2F;是否开启渲染脚本</span><br><span class="line"></span><br><span class="line">       renderscriptOptimLevel 5    &#x2F;&#x2F;渲染脚本等级 默认是5</span><br><span class="line"></span><br><span class="line">       zipAlignEnabled true   &#x2F;&#x2F;是否zip对齐优化 默认就是true app对齐</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ndkDirectory"><a href="#ndkDirectory" class="headerlink" title="ndkDirectory"></a>ndkDirectory</h3><p>The NDK directory used.<br>NDK路径，也可以在local.properties 中配置 ndk.dir=/Users/xxxx/Library/Android/sdk</p>
<h3 id="sdkDirectory"><a href="#sdkDirectory" class="headerlink" title="sdkDirectory"></a>sdkDirectory</h3><p>The SDK directory used.<br>同ndkDirectory，目前一般配置在local.properties。</p>
<h3 id="aaptOptions"><a href="#aaptOptions" class="headerlink" title="aaptOptions"></a>aaptOptions</h3><p>Options for aapt, tool for packaging resources.<br>aapt是一个资源打包工具，可以对资源优化做一些动态配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">aaptOptions&#123;</span><br><span class="line">        additionalParameters &#39;--rename-manifest-package&#39;,</span><br><span class="line">                &#39;cct.cn.gradle.lsn13&#39;,&#39;-S&#39;,&#39;src&#x2F;main&#x2F;res2&#39;,&#39;--auto-add-overlay&#39;  &#x2F;&#x2F;aapt执行时的额外参数 </span><br><span class="line"></span><br><span class="line">        cruncherEnabled true    &#x2F;&#x2F;对png进行优化检查</span><br><span class="line"></span><br><span class="line">        ignoreAssets &#39;*.jpg&#39;  &#x2F;&#x2F;对res目录下的资源文件进行排除 把res文件夹下面的所有.jpg格式的文件打包到apk中</span><br><span class="line"></span><br><span class="line">        noCompress &#39;.jpg&#39;   &#x2F;&#x2F;对所有.jpg文件不进行压缩</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="adbExecutable"><a href="#adbExecutable" class="headerlink" title="adbExecutable"></a>adbExecutable</h3><p>The adb executable from the compile SDK.<br>adb工具的文件路径，可以配置在环境变量中。</p>
<h3 id="adbOptions"><a href="#adbOptions" class="headerlink" title="adbOptions"></a>adbOptions</h3><p>Adb options.<br>adb命令的一些配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adbOptions   &#123;</span><br><span class="line">    installOptions &#39;-r&#39; &#39;-d&#39;  &#x2F;&#x2F;调用adb install命令时默认传递的参数</span><br><span class="line"></span><br><span class="line">    timeOutInMs 1000   &#x2F;&#x2F;执行adb命令的超时时间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="compileOptions"><a href="#compileOptions" class="headerlink" title="compileOptions"></a>compileOptions</h3><p>Compile options.<br>编译配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">compileOptions&#123;</span><br><span class="line">        encoding &#39;UTF-8&#39;  &#x2F;&#x2F;java源文件的编码格式 默认UTF-8</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        incremental true    &#x2F;&#x2F;java编译是否使用gradle新的增量模式 </span><br><span class="line"></span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_7    &#x2F;&#x2F;java源文件编译的jdk版本 </span><br><span class="line">        </span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_7   &#x2F;&#x2F;编译出的class的版本</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="dataBinding"><a href="#dataBinding" class="headerlink" title="dataBinding"></a>dataBinding</h3><p>Data Binding options.<br>DataBinding的使用细节可以查看 <a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/data-binding/index.html">Google文档</a>,可以在build.gradle中开启DataBinding：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataBinding  &#123;</span><br><span class="line">      enabled &#x3D; true   &#x2F;&#x2F;开启databinding</span><br><span class="line">      version &#x3D; &quot;1.0&quot;</span><br><span class="line">      addDefaultAdapters &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defaultPublishConfig"><a href="#defaultPublishConfig" class="headerlink" title="defaultPublishConfig"></a>defaultPublishConfig</h3><p>Name of the configuration used to build the default artifact of this project.<br>指定发布的渠道及BuildType类型。在Library中使用，默认Release。</p>
<h3 id="signingConfigs"><a href="#signingConfigs" class="headerlink" title="signingConfigs"></a>signingConfigs</h3><p>Signing configs used by this project.<br>一个签名配置的列表，可以供不同渠道和buildType使用。</p>
<h3 id="lintOptions"><a href="#lintOptions" class="headerlink" title="lintOptions"></a>lintOptions</h3><p>Lint options.<br>Lint可以检查出代码中一些不规范的使用，如果想保留一些苟且的代码，可以参考以下配置（简友lyzaijs同学对这一块有详细说明，下面引用自他的博客）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">lintOptions &#123; </span><br><span class="line">        quiet true &#x2F;&#x2F; 设置为 true时lint将不报告分析的进度</span><br><span class="line">       </span><br><span class="line">        abortOnError false    &#x2F;&#x2F; 如果为 true，则当lint发现错误时停止 gradle构建</span><br><span class="line">        </span><br><span class="line">        ignoreWarnings true   &#x2F;&#x2F; 如果为 true，则只报告错误</span><br><span class="line">       </span><br><span class="line">        absolutePaths true   &#x2F;&#x2F; 如果为 true，则当有错误时会显示文件的全路径或绝对路径 </span><br><span class="line">        </span><br><span class="line">        checkAllWarnings true  &#x2F;&#x2F; 如果为 true，则检查所有的问题，包括默认不检查问题</span><br><span class="line">        </span><br><span class="line">        warningsAsErrors true  &#x2F;&#x2F; 如果为 true，则将所有警告视为错误</span><br><span class="line">        </span><br><span class="line">        disable &#39;TypographyFractions&#39;,&#39;TypographyQuotes&#39;  &#x2F;&#x2F; 不检查给定的问题id</span><br><span class="line">       </span><br><span class="line">        enable &#39;RtlHardcoded&#39;,&#39;RtlCompat&#39;, &#39;RtlEnabled&#39;   &#x2F;&#x2F; 检查给定的问题 id</span><br><span class="line">     </span><br><span class="line">        check &#39;NewApi&#39;, &#39;InlinedApi&#39;    &#x2F;&#x2F; * 仅 * 检查给定的问题 id</span><br><span class="line">       </span><br><span class="line">        noLines true  &#x2F;&#x2F; 如果为true，则在错误报告的输出中不包括源代码行</span><br><span class="line">        </span><br><span class="line">        showAll true  &#x2F;&#x2F; 如果为 true，则对一个错误的问题显示它所在的所有地方，而不会截短列表，等等。</span><br><span class="line">        </span><br><span class="line">        lintConfig file(&quot;default-lint.xml&quot;)  &#x2F;&#x2F; 重置 lint 配置（使用默认的严重性等设置）。</span><br><span class="line">       </span><br><span class="line">        textReport true  &#x2F;&#x2F; 如果为 true，生成一个问题的纯文本报告（默认为false）</span><br><span class="line">        </span><br><span class="line">        textOutput &#39;stdout&#39; &#x2F;&#x2F; 配置写入输出结果的位置；它可以是一个文件或 “stdout”（标准输出）</span><br><span class="line">        </span><br><span class="line">        xmlReport false &#x2F;&#x2F; 如果为真，会生成一个XML报告，以给Jenkins之类的使用</span><br><span class="line">       </span><br><span class="line">        xmlOutput file(&quot;lint-report.xml&quot;)  &#x2F;&#x2F; 用于写入报告的文件（如果不指定，默认为lint-results.xml）</span><br><span class="line">        </span><br><span class="line">        htmlReport true &#x2F;&#x2F; 如果为真，会生成一个HTML报告（包括问题的解释，存在此问题的源码，等等）</span><br><span class="line">       </span><br><span class="line">        htmlOutput file(&quot;lint-report.html&quot;)  &#x2F;&#x2F; 写入报告的路径，它是可选的（默认为构建目录下的 lint-results.html ）</span><br><span class="line"></span><br><span class="line">        checkReleaseBuilds true   &#x2F;&#x2F; 设置为 true， 将使所有release 构建都以issus的严重性级别为fatal（severity&#x3D;false）的设置来运行lint，并且，如果发现了致命（fatal）的问题，将会中止构建（由上面提到的 abortOnError 控制.</span><br><span class="line"></span><br><span class="line">        fatal &#39;NewApi&#39;, &#39;InlineApi&#39;  &#x2F;&#x2F;设置给定问题的严重级别（severity）为fatal （这意味着他们将会在release构建的期间检查 （即使 lint 要检查的问题没有包含在代码中)</span><br><span class="line">        </span><br><span class="line">        error &#39;Wakelock&#39;, &#39;TextViewEdits&#39;   &#x2F;&#x2F; 设置给定问题的严重级别为error</span><br><span class="line">        </span><br><span class="line">        warning &#39;ResourceAsColor&#39;   &#x2F;&#x2F; 设置给定问题的严重级别为warning</span><br><span class="line">       </span><br><span class="line">        ignore &#39;TypographyQuotes&#39;    &#x2F;&#x2F; 设置给定问题的严重级别（severity）为ignore （和不检查这个问题一样）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###dexOptions<br>Dex options.<br>Android dx工具是将java的classes文件编译为字节码dex文件，工具位于android sdk platform-tools目录，我们在做热修复做差分包的时候可能会用到这个工具，在android打包过程中，dx的可以做以下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dexOptions &#123;</span><br><span class="line">        additionalParameters &#39;--minimal-main-dex&#39;,&#39;--set-max-idx-number&#x3D;10000&#39;  &#x2F;&#x2F;dx命令附加参数</span><br><span class="line"></span><br><span class="line">        javaMaxHeapSize &#39;2048m&#39;    &#x2F;&#x2F;执行dx时java虚拟机可用的最大内存大小</span><br><span class="line"></span><br><span class="line">        jumboMode true   &#x2F;&#x2F;开启大模式，所有的class打到一个dex中，可以忽略65535方法数的限制，低于14版本不可运行</span><br><span class="line"></span><br><span class="line">        keepRuntimeAnnotatedClasses true &#x2F;&#x2F;在dex中是否保留Runtime注解 默认是true</span><br><span class="line"></span><br><span class="line">        maxProcessCount 4   &#x2F;&#x2F;默认dex中的进程数  默认是4 </span><br><span class="line"></span><br><span class="line">        threadCount 4  &#x2F;&#x2F;默认的线程数</span><br><span class="line"></span><br><span class="line">        preDexLibraries true  &#x2F;&#x2F;对library预编译 提高编译效率 但是clean的时候比较慢  默认开启的</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="packagingOptions"><a href="#packagingOptions" class="headerlink" title="packagingOptions"></a>packagingOptions</h3><p>Packaging options.<br>打包配置，尤其是在一些多模块开发工程中，涉及到的一些资源合并取舍的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">packagingOptions   &#123;</span><br><span class="line">       </span><br><span class="line">        pickFirsts &#x3D; [&#39;META-INF&#x2F;LICENSE&#39;]    &#x2F;&#x2F;pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk</span><br><span class="line"></span><br><span class="line">        merge &#39;META-INF&#x2F;LICENSE&#39;  &#x2F;&#x2F;重复文件会合并打包入apk</span><br><span class="line"></span><br><span class="line">        exclude &#39;META-INF&#x2F;LICENSE&#39;    &#x2F;&#x2F;打包时排除匹配文件</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="sourceSets"><a href="#sourceSets" class="headerlink" title="sourceSets"></a>sourceSets</h3><p>All source sets. Note that the Android plugin uses its own implementation of source sets, AndroidSourceSet.An AndroidSourceSet represents a logical group of Java, aidl and RenderScript sources as well as Android and non-Android (Java-style) resources.</p>
<p>所有Android资源的集合，包括Java代码，aidl以及RenderScript。默认配置如下，有一些自定义路径的情况下需要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sourceSets&#123;</span><br><span class="line">        main  &#123;</span><br><span class="line">            res.srcDirs &#39;src&#x2F;main&#x2F;res&#39; </span><br><span class="line">            jniLibs.srcDirs &#x3D; [&#39;libs&#39;] </span><br><span class="line">            aidl.srcDirs &#39;src&#x2F;main&#x2F;aidl&#39;</span><br><span class="line">            assets.srcDirs &#39;src&#x2F;main&#x2F;assets&#39;</span><br><span class="line">            java.srcDirs &#39;src&#x2F;main&#x2F;java&#39;</span><br><span class="line">            jni.srcDirs &#39;src&#x2F;main&#x2F;jni&#39;</span><br><span class="line">            renderscript.srcDirs &#39;src&#x2F;main&#x2F;renderscript&#39; </span><br><span class="line">            resources.srcDirs &#39;src&#x2F;main&#x2F;resources&#39;</span><br><span class="line">            manifest.srcFile &#39;src&#x2F;main&#x2F;AndroidManifest.xml&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free  &#123;   &#x2F;&#x2F;除了main,也可以给不同的渠道指定不同的配置</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="splits"><a href="#splits" class="headerlink" title="splits"></a>splits</h3><p>APK splits options.<br>这个特性非常有用，不过国内应用基本使用不上，可以根据CPU架构和屏幕像素密度打出最小的apk包，再配合Google Play的市场分发机制，让你可以下载到适合你使用的apk。有abi、density、language三个维度进行过滤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">splits  &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enable true  &#x2F;&#x2F;开启abi分包</span><br><span class="line"></span><br><span class="line">            universalApk true  &#x2F;&#x2F;是否创建一个包含所有有效动态库的apk</span><br><span class="line"></span><br><span class="line">            reset()  &#x2F;&#x2F;清空defaultConfig配置</span><br><span class="line"></span><br><span class="line">            include &#39;x86&#39;,&#39;armeabi&#39; &#x2F;&#x2F;打出包含的包 这个是和defaultConfig累加的</span><br><span class="line"></span><br><span class="line">            exclude &#39;mips&#39;   &#x2F;&#x2F;排除指定的cpu架构</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        density &#123;</span><br><span class="line">            </span><br><span class="line">            enable true  &#x2F;&#x2F;开启density分包</span><br><span class="line"></span><br><span class="line">            reset()  &#x2F;&#x2F;清空所有默认值</span><br><span class="line"></span><br><span class="line">            include &#39;xhdpi&#39;,&#39;xxhdpi&#39;   &#x2F;&#x2F;打出包含的包 这个是和默认值累加的</span><br><span class="line"></span><br><span class="line">            exclude &#39;mdpi&#39; &#x2F;&#x2F;排除指定</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        language &#123;</span><br><span class="line">              enable true  &#x2F;&#x2F;开启language分包</span><br><span class="line">              include &#39;en&#39;,&#39;cn&#39;  &#x2F;&#x2F; 指定语言</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="variantFilter"><a href="#variantFilter" class="headerlink" title="variantFilter"></a>variantFilter</h3><p>Callback to control which variants should be excluded.<br>上面我们通过flavor及buildType构建出大量的apk，这里可能有你不需要的，android plugin也考虑到这一点，可以动态设置忽略一些产出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">variantFilter &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">        def buildTypeName &#x3D; variant.buildType.name</span><br><span class="line">        def flavorName &#x3D; variant.flavors.name</span><br><span class="line"></span><br><span class="line">        if (flavorName.contains(&quot;360&quot;) &amp;&amp; buildTypeName.contains(&quot;debug&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Tells Gradle to ignore each variant that satisfies the conditions above.</span><br><span class="line">            setIgnore(true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="LibraryExtension"><a href="#LibraryExtension" class="headerlink" title="LibraryExtension"></a>LibraryExtension</h1><h3 id="libraryVariants"><a href="#libraryVariants" class="headerlink" title="libraryVariants"></a>libraryVariants</h3><p>The list of library variants. Since the collections is built after evaluation, it should be used with Gradle’s all iterator to process future items.</p>
<p>libraryVariants也有类似于applicationVariants的all闭包，可以获取到所有的应用回调，其中可以做一些特定的设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android.libraryVariants.all &#123; variant -&gt;</span><br><span class="line">    def mergedFlavor &#x3D; variant.getMergedFlavor()</span><br><span class="line">    &#x2F;&#x2F; Defines the value of a build variable you can use in the manifest.</span><br><span class="line">    mergedFlavor.manifestPlaceholders &#x3D; [hostName:&quot;www.example.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是对AppExtension及LibraryExtension的一个详细说明，这个Android Plugin所有task运行的基础配置，下一节将关注我们常用的task实现以及其中的依赖关系。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a target="_blank" rel="noopener" href="http://google.github.io/android-gradle-dsl/current/">http://google.github.io/android-gradle-dsl/current/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/dsl/">https://docs.gradle.org/current/dsl/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:05:15.000Z" title="2020-12-19T11:05:15.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:05:48.593Z" title="2020-12-19T11:05:48.593Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/Gson%E5%A2%9E%E9%87%8F%E8%A7%A3%E6%9E%90/">Gson增量解析</a></h1><div class="content"><p>增量解析是我自己杜撰的一个名词，主要是有这样的场景，移动端请求服务端json数据的时候，考虑到流量资源的珍贵，如果本地已经请求过完整下信息，一般是将一个model更新的字段下发，而不是每次都下发完整的model。举个例子，我们向服务器请求user的信息，完整的数据格式可能是：</p>
<blockquote>
<p>{“age”:20,”id”:1,”name”:”张三”,”sex”:”男”}</p>
</blockquote>
<p>User中的id、name、sex可能是一直不变的，而age是有可能发生变化的，当客户端刷新user的信息时，服务端只下发age的信息就行了，以达到节省流量的目的，下发的数据格式可能是：</p>
<blockquote>
<p>{“age”:25,”id”:1}</p>
</blockquote>
<p>只有age发生变化，所以只下发了age的信息，id作为识别字段。我们用Gson解析的时候一般是直接调用fromJson函数，这个函数接受两个参数，一个是json字符串，一个是解析的model类。对于这种只有部分数据的json我们如何解析呢，难道重新定义一个SubUser类，处理这种解析然后赋值给User吗，这样做的代价是非常不灵活，更新的字段必须客户端写死，如果下次name或者sex也发生了变化呢，是不是SubUser类就需要修改然后发版？</p>
<p>能不能有个类似于fromJson的函数，他的第二个参数不再是一个类，而是一个实例，新的json数据只会更新这个实例的某些字段。Gson在解析的时候会调用model的默认构造函数new出一个实例，能不能不让它new而是直接在原有的实例基础上进行解析呢？查看Gson的官方文档，看到可以给Gson注册一个InstanceCreator，它是一个接口，顾名思义它是提供用户一个初始化model的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface InstanceCreator&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public T createInstance(Type type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以把原来的user作为初始化的实例，实现增量更新的解析。这是对于object的解析，可以这么做。如果是list呢，如何进行增量解析呢，总不能把原来的list作为返回值吧，目前我还没有很好的思路，只是将列表拆分成object分别进行解析。</p>
<p>下面简单的写一个demo：</p>
<p>User类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line"></span><br><span class="line">    public long id;</span><br><span class="line"></span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    public String sex;</span><br><span class="line"></span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GsonCreatorHelper类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class GsonCreatorHelper &#123;</span><br><span class="line"></span><br><span class="line">    public static User fromJson(String json, final User old) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            JSONObject object &#x3D; new JSONObject(json);</span><br><span class="line">            long id &#x3D; object.getLong(&quot;id&quot;);</span><br><span class="line">            if (id &#x3D;&#x3D; old.getId()) &#123;</span><br><span class="line">                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(User.class, new InstanceCreator&lt;User&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public User createInstance(Type type) &#123;</span><br><span class="line">                        return old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br><span class="line">                return gson.fromJson(json, User.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Gson().fromJson(json, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;User&gt; fromJson(String json, final List&lt;User&gt; old) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;User&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            JSONArray array &#x3D; new JSONArray(json);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; array.length(); i++) &#123;</span><br><span class="line">                JSONObject object &#x3D; array.getJSONObject(i);</span><br><span class="line">                final long id &#x3D; object.getLong(&quot;id&quot;);</span><br><span class="line">                Gson gson &#x3D; new GsonBuilder().registerTypeAdapter(User.class, new InstanceCreator&lt;User&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public User createInstance(Type type) &#123;</span><br><span class="line">                        return getUserById(old, id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).create();</span><br><span class="line">                result.add(gson.fromJson(object.toString(), User.class));</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (JSONException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new Gson().fromJson(json, new TypeToken&lt;List&lt;User&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static User getUserById(List&lt;User&gt; users, long id) &#123;</span><br><span class="line">        for (User user : users) &#123;</span><br><span class="line">            if (user.getId() &#x3D;&#x3D; id) &#123;</span><br><span class="line">                return user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivity测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        String json1 &#x3D; &quot;&#123;\&quot;age\&quot;:20,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;&quot;;</span><br><span class="line">        String json2 &#x3D; &quot;&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:1&#125;&quot;;</span><br><span class="line">        String json3 &#x3D; &quot;[&#123;\&quot;age\&quot;:20,\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;,&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:2,\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;sex\&quot;:\&quot;男\&quot;&#125;]&quot;;</span><br><span class="line">        String json4 &#x3D; &quot;[&#123;\&quot;age\&quot;:23,\&quot;id\&quot;:1&#125;,&#123;\&quot;age\&quot;:33,\&quot;id\&quot;:2&#125;]&quot;;</span><br><span class="line"></span><br><span class="line">        User user1 &#x3D; new Gson().fromJson(json1, User.class);</span><br><span class="line">        Log.e(&quot;user1&quot;, new Gson().toJson(user1));</span><br><span class="line"></span><br><span class="line">        User user2 &#x3D; GsonCreatorHelper.fromJson(json2, user1);</span><br><span class="line">        Log.e(&quot;user2&quot;, new Gson().toJson(user2));</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; user3 &#x3D; new Gson().fromJson(json3, new TypeToken&lt;ArrayList&lt;User&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">        Log.e(&quot;user3&quot;, new Gson().toJson(user3));</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; user4 &#x3D; GsonCreatorHelper.fromJson(json4, user3);</span><br><span class="line">        Log.e(&quot;user4&quot;, new Gson().toJson(user4));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10-08 18:18:41.419 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user1: &#123;&quot;age&quot;:20,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="line">10-08 18:18:41.425 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user2: &#123;&quot;age&quot;:23,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;</span><br><span class="line">10-08 18:18:41.436 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user3: [&#123;&quot;age&quot;:20,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:23,&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]</span><br><span class="line">10-08 18:18:41.441 28438-28438&#x2F;com.panda.gsoninstancecreatortest E&#x2F;user4: [&#123;&quot;age&quot;:23,&quot;id&quot;:1,&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:33,&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]</span><br></pre></td></tr></table></figure>
<p>从结果中我们可以看到user2和user4都是在user1和user3的基础上继续解析了新的json数据。大功告成！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T11:02:48.000Z" title="2020-12-19T11:02:48.000Z">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T11:04:39.233Z" title="2020-12-19T11:04:39.233Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/19/Flutter%E6%8E%A5%E5%85%A5%E7%8E%B0%E6%9C%89Android%E5%B7%A5%E7%A8%8B%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/">Flutter接入现有Android工程踩坑之旅</a></h1><div class="content"><p>把Flutter作为一个模块接入到现有的Android工程，Flutter有官方推荐方案 <a target="_blank" rel="noopener" href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps#preview-use-the-flutter-module-template">Add Flutter to existing apps</a>,通过这样的工程配置，可以在debug支持HotReload，也可以输出Release包供发布。不过在使用过程中有一些需要调整的地方，特此记录希望对大家能有借鉴意义。</p>
<h3 id="工程目录调整"><a href="#工程目录调整" class="headerlink" title="工程目录调整"></a>工程目录调整</h3><blockquote>
<p>flutter create -t module</p>
</blockquote>
<p>命令会创建一个支持Flutter的Android Library，其中Android Library的目录位于Flutter工程的隐藏目录    <strong>.android/flutter</strong>      中, 一般情况下，我们会把Flutter代码和Android代码放在两个git仓库，通过submodule的方式进行依赖，可以把这个Library的代码copy到你的工程目录下，同时修改flutter的资源目录到你自己的相对路径下：</p>
<blockquote>
<p>flutter {<br>source ‘ <strong>your own flutter project directory</strong> ‘<br>}</p>
</blockquote>
<p>另外需要Copy <strong>include_flutter.groovy</strong> 这个文件到你的工程目录下，修改相应的目录添加对于Library的依赖。</p>
<h3 id="armeabi支持"><a href="#armeabi支持" class="headerlink" title="armeabi支持"></a>armeabi支持</h3><p>Flutter官方只提供了四种CPU架构的SO库：armeabi-v7a、arm64-v8a、x86和x86-64。但是目前我们对接的两个项目组分别是只支持armeabi和只支持armeabi-v7a，所以需要对官方的jar包进行改造。官方SDK提供的jar包路径在  <em>$flutterRoot/bin/cache/artifacts/engine</em>中,复制这几个目录下的armeabi-v7a中的so到armeabi路径下：</p>
<ul>
<li>android-arm</li>
<li>android-arm-dynamic-profile</li>
<li>android-arm-dynamic-release</li>
<li>android-arm-profile</li>
<li>android-arm-release</li>
</ul>
<p>可以通过如下脚本实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip flutter.jar lib&#x2F;armeabi-v7a&#x2F;libflutter.so</span><br><span class="line">mkdir lib&#x2F;armeabi</span><br><span class="line">cp lib&#x2F;armeabi-v7a&#x2F;libflutter.so lib&#x2F;armeabi&#x2F;libflutter.so</span><br><span class="line">zip flutter.jar lib&#x2F;armeabi-v7a&#x2F;libflutter.so lib&#x2F;armeabi&#x2F;libflutter.so</span><br></pre></td></tr></table></figure>
<p>Library中的build.gradle中有一段是通过本地的一个gradle文件添加flutter.jar的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;$flutterRoot&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter.gradle&quot;</span><br></pre></td></tr></table></figure>
<p>我们把flutter.gradle文件以及我们刚才处理的flutter.jar文件Copy到自己的工程路径下，我自己的工程路径配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">│   app</span><br><span class="line">└───flutter</span><br><span class="line">│   │   build.gradle</span><br><span class="line">│   │   flutter.gradle</span><br><span class="line">│   │   include_flutter.groovy</span><br><span class="line">│   └───flutter-jars</span><br><span class="line">│       └───android-arm</span><br><span class="line">|              |   flutter.jar</span><br><span class="line">│       └───android-arm-dynamic-profile</span><br><span class="line">|              |   flutter.jar</span><br><span class="line">│       └───android-arm-dynamic-release</span><br><span class="line">|              |   flutter.jar</span><br><span class="line">|       └───android-arm-profile</span><br><span class="line">|              |   flutter.jar</span><br><span class="line">|       └───aandroid-arm-release</span><br><span class="line">|              |   flutter.jar</span><br><span class="line">│   settings.gradle</span><br></pre></td></tr></table></figure>
<p>将flutter.gradle 中jar文件的路径改为本地工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debugFlutterJar &#x3D; new File(&#39;flutter-jars&#x2F;debug&#x2F;flutter.jar&#39;)</span><br><span class="line">profileFlutterJar &#x3D; new File(&#39;flutter-jars&#x2F;profile&#x2F;flutter.jar&#39;)</span><br><span class="line">releaseFlutterJar &#x3D; new File(&#39;flutter-jars&#x2F;release&#x2F;flutter.jar&#39;)</span><br><span class="line">dynamicProfileFlutterJar &#x3D; new File(&#39;flutter-jars&#x2F;dynamicProfile&#x2F;flutter.jar&#39;)</span><br><span class="line">dynamicReleaseFlutterJar &#x3D; new File(&#39;flutter-jars&#x2F;dynamicRelease&#x2F;flutter.jar&#39;)</span><br></pre></td></tr></table></figure>
<p>这样打出的AAR就能同时支持两种架构。</p>
<h3 id="打包AAR问题"><a href="#打包AAR问题" class="headerlink" title="打包AAR问题"></a>打包AAR问题</h3><p>按照上面的配置，可以在工程中打出支持Debug HotReload和Release的包，不过在输出AAR给别的业务模块使用时会报一个崩溃：</p>
<blockquote>
<p>must be able to initialize the ICU context.</p>
</blockquote>
<p>这是Android Gradle Plugin 3.+ 版本的一个bug，它会丢弃flutter.jar 中的 /assets/flutter_shared/icudtl.dat文件到AAR中，导致运行时找不到这个文件崩溃，在2.+版本中发现没有这个问题，所以需要使用Android Gradle Plugin 2.+版本，我这边测试2.2.3版本是ok的。但是Android Gradle 2的版本有一个由来已久的问题就是Library不能获取project一致 的BuildType,Library默认只发布Release的AAR。这是因为Android中默认指定了发布type:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private String defaultPublishConfig &#x3D; &quot;release&quot;;</span><br><span class="line">private boolean publishNonDefault &#x3D; false;</span><br></pre></td></tr></table></figure>
<p> 默认Release，而flutter.gradle中通过buildtype来确定flutter的buildmode,在Android Gradle Plugin 3.+版本中，这个buildtype的问题已经得到解决，这也可能是flutter选用3.+版本的一个原因。</p>
<p> 如果避免2.+的buildtype问题呢，网上是有一些获取project的buildtype配置给Library的方案，比如<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3751f95a6480">如何让library的buildType类型跟app的buildType类型一致(自由定义library的buildType) ??</a>。 我的实现方案是摈弃通过buildtype确定flutter的buildmode的方案，通过直接读取本地local.properties中的参数来决定，这样需要自己在本地手动的进行mode的切换，尤其是要注意上线的时候修改为Release模式。不过debug模式下页面有明显的debug标识，所以一般也不会出错。将flutter.gradle 中原有的buildmodefor方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static String buildModeFor(buildType) &#123;</span><br><span class="line">       if (buildType.name &#x3D;&#x3D; &quot;profile&quot;) &#123;</span><br><span class="line">           return &quot;profile&quot;</span><br><span class="line">       &#125; else if (buildType.name &#x3D;&#x3D; &quot;dynamicProfile&quot;) &#123;</span><br><span class="line">           return &quot;dynamicProfile&quot;</span><br><span class="line">       &#125; else if (buildType.name &#x3D;&#x3D; &quot;dynamicRelease&quot;) &#123;</span><br><span class="line">           return &quot;dynamicRelease&quot;</span><br><span class="line">       &#125; else if (buildType.debuggable) &#123;</span><br><span class="line">           return &quot;debug&quot;</span><br><span class="line">       &#125;</span><br><span class="line">       return &quot;release&quot;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String buildModeFor(Project project) &#123;</span><br><span class="line">        return resolveProperty(project, &#39;flutter.buildMode&#39;, &#39;release&#39;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样在local.properties 中就可以进行debug和Release的切换：</p>
<blockquote>
<p>flutter.buildMode=release</p>
</blockquote>
<blockquote>
<p>flutter.buildMode=debug</p>
</blockquote>
<h3 id="切换mode的崩溃问题"><a href="#切换mode的崩溃问题" class="headerlink" title="切换mode的崩溃问题"></a>切换mode的崩溃问题</h3><p>在第一次配置好工程或者切换mode的过程中，可能会遇到以下的崩溃问题：</p>
<blockquote>
<p>Check failed: vm. Must be able to initialize the VM.</p>
</blockquote>
<p>主要是由于不同模式下的产物没有清理使用了缓存，解决办法是删除掉所有build文件的内容再全量编译一次就可以了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是我在做flutter工程配置中遇到的一些坑，文风偏流水账，请大家见谅，只希望能对大家有一些借鉴意义。另外，我们已经在项目的两个模块中使用了flutter，开发效率确实能有很大提高，毕竟两端只需要一个人开发就ok，而且UI小姐姐要求的页面效果都能不折不扣的完成，上线之后目前还没发现什么问题。下一步需要做的是建立一个有效的监控体系，毕竟靠用户反馈还是不可靠也是滞后的。相信Flutter的未来一定是光明的！</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-17T14:06:52.000Z" title="2020-12-17T14:06:52.000Z">2020-12-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-12-19T10:53:36.124Z" title="2020-12-19T10:53:36.124Z">2020-12-19</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/17/HTTPS%E5%8E%9F%E7%90%86%E5%8F%8AOKHTTP%E5%AF%B9HTTPS%E7%9A%84%E6%94%AF%E6%8C%81/">HTTPS原理及OKHTTP对HTTPS的支持</a></h1><div class="content"><h1 id="HTTPS原理"><a href="#HTTPS原理" class="headerlink" title="HTTPS原理"></a>HTTPS原理</h1><p>我们先看一下定义，来自wikipedia的一个介绍：</p>
<blockquote>
<p>HTTPS  (also called <strong>HTTP over Transport Layer Security (TLS)</strong>, <strong>HTTP over SSL</strong>, and <strong>HTTP Secure</strong>) is a communications protocol for secure communication over a computer network which is widely used on the Internet. HTTPS consists of communication over Hypertext Transfer Protocol (HTTP) within a connection encrypted by Transport Layer Security, or its predecessor, Secure Sockets Layer. The main motivation for HTTPS is authentication of the visited website and protection of the privacy and integrity of the exchanged data.</p>
</blockquote>
<p>从这个定义中我们可以看出，HTTPS是包含了HTTP协议及SSL /TLS协议这两部分内容，简单的理解就是基于SSL/TLS进行HTTP的加密传输。HTTP是一个应用层的协议，定义了很多请求和响应方通信的遵循的规则，这部分内容可以从<a target="_blank" rel="noopener" href="https://www.amazon.cn/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%90%89%E5%B0%94%E5%88%A9/dp/B008XFDQ14/ref=sr_1_1/460-1292118-1495910?s=books&ie=UTF8&qid=1502806302&sr=1-1&keywords=HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">HTTP权威指南</a>这部巨作中得到很详细的介绍，这里就不赘述了。其实主要还是想探讨一下SSL/TLS协议的一些具体细节，毕竟这是HTTPS区别于HTTP最大的地方，首先我们来看一下一个SSL/TLS完整的握手过程。</p>
<p><img src="../images/1.jpeg" alt="SSL/TLS握手过程"></p>
<p>很复杂的交互过程，但是理解下来就是用非对称加密的手段传递密钥，然后用密钥进行对称加密传递数据。在这个握手过程中最重要的就是证书校验，其他就是正常的数据交互过程。如何校验一个证书合法有很大的文章，处理不好就会让你的网络失去了安全性。一个证书的校验，主要包括以下几个方面：</p>
<ul>
<li>第一，校验证书是否是由客户端中“受信任的根证书颁发机构”颁发；</li>
<li>第二，校验证书是否在上级证书的吊销列表；</li>
<li>第三，校验证书是否过期；</li>
<li>第四，校验证书域名是否一致。</li>
</ul>
<p>一天我们的QA妹子气愤愤的找到我说，为啥别人的APP可以用Charles抓到HTTPS的包，为啥我们的不能，我心中窃喜的告诉她只能说明我们技高一筹了。具体如何做到的后面我会分享一下我们的做法，先讨论一下Charles如何实现https的抓包的，这里面涉及到一个中间人攻击的问题。</p>
<p>一个针对SSL的中间人攻击过程如下：</p>
<p><img src="../images/2.jpeg" alt="image.png"></p>
<p>中间人其实是做了一个偷梁换柱的动作，核心是如何欺骗客户端，从而让客户端能够放心的与中间人进行数据交互而没有任何察觉。我们来看Charles如何做到HTTPS抓包的，网上有很多Charles如何抓HTTPS包的教程，几步就搞定了，其中最核心的就是：</p>
<blockquote>
<p>将私有CA签发的数字证书安装到手机中并且作为受信任证书保存</p>
</blockquote>
<p>自签发一个证书实现上述二、三、四条校验规则很简单，要把这个证书安装到手机端信任列表必须得到用户的许可，这里不好绕过，但是鉴于大部分用户的网络安全意识比较差，有时也会稀里糊涂的信任了，那我们作为APP的开发人员，能否避免这种情况的发生呢？</p>
<p>其实也很简单，我们把服务端的证书内置在我们的APP里，我们在做服务端证书校验的时候只比对是否和这个证书完全相同，不同就直接抛错，那中间人便没有办法绕过证书进行攻击。但是这里面也有一个问题就是服务端的证书可能会过期或者升级，而且服务端往往为了提高网络的安全性，证书的有效时间不会设置太长，这样APP就会因为这个证书的事情频繁发版，也很痛苦。（前段时间我司IOS的APP就是因为授权企业用户的证书没有及时更新，导致大家无法正常打开APP，血的教训导致我们不想重走这条路）可能你又想到了，我们可以把证书配置在后端，有更新的时候直接去下载不就完了，那我们的证书下载没有没拦截的风险吗，一旦拦截，我们所有的证书校验都会失效，比直接信任手机内置的证书更可怕。我们既不想只信任我们服务器的证书，又不想信任手机上所有的 CA 证书。有个不错的的信任方式是把签发我们服务器的证书的根证书导出打包到APP中，这样虽然不能做到百分之百的证书无漏洞，但是相比于信任手机中几百个证书，我们只信任一个风险会小很多，这也就是我们的QA妹子用Charles抓不了我们的包的原因。~~~</p>
<h1 id="OKHTTP"><a href="#OKHTTP" class="headerlink" title="OKHTTP"></a>OKHTTP</h1><p>作为一个Android开发者，我们来看一下广泛使用的网络库OKHTTP对于HTTPS的支持。下面这段话摘自OKHTTP对于HTTPS的介绍中（<a target="_blank" rel="noopener" href="https://github.com/square/okhttp/wiki/HTTPS">地址请戳</a>）：</p>
<p>OkHttp attempts to balance two competing concerns:</p>
<ul>
<li><strong>Connectivity</strong> to as many hosts as possible. That includes advanced hosts that run the latest versions of <a target="_blank" rel="noopener" href="https://boringssl.googlesource.com/boringssl/">boringssl</a> and less out of date hosts running older versions of <a target="_blank" rel="noopener" href="https://www.openssl.org/">OpenSSL</a>.</li>
<li><strong>Security</strong> of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers.</li>
</ul>
<p>几个与HTTPS相关的API：</p>
<h3 id="SSLSocketFactory"><a href="#SSLSocketFactory" class="headerlink" title="SSLSocketFactory:"></a>SSLSocketFactory:</h3><p>安全套接层工厂，用于创建SSLSocket。默认的SSLSocket是信任手机内置信任的证书列表，我们可以通过OKHttpClient.Builder的sslSocketFactory方法定义我们自己的信任策略，比如实现上面提到的我们只信任服务端证书的根证书，代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 载入证书</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static SSLSocketFactory getSSLSocketFactory(InputStream... certificates) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">&#x2F;&#x2F;用我们的证书创建一个keystore</span><br><span class="line">            CertificateFactory certificateFactory &#x3D; CertificateFactory.getInstance(&quot;X.509&quot;);</span><br><span class="line">            KeyStore keyStore &#x3D; KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            keyStore.load(null);</span><br><span class="line">            int index &#x3D; 0;</span><br><span class="line">            for (InputStream certificate : certificates) &#123;</span><br><span class="line">                String certificateAlias &#x3D; &quot;server&quot;+Integer.toString(index++);</span><br><span class="line">                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (certificate !&#x3D; null) &#123;</span><br><span class="line">                        certificate.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;创建一个trustmanager，只信任我们创建的keystore</span><br><span class="line">            SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            TrustManagerFactory trustManagerFactory &#x3D;</span><br><span class="line">                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            trustManagerFactory.init(keyStore);</span><br><span class="line">            sslContext.init(</span><br><span class="line">                    null,</span><br><span class="line">                    trustManagerFactory.getTrustManagers(),</span><br><span class="line">                    new SecureRandom()</span><br><span class="line">            );</span><br><span class="line">            return sslContext.getSocketFactory();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="X509TrustManager"><a href="#X509TrustManager" class="headerlink" title="X509TrustManager:"></a>X509TrustManager:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface X509TrustManager extends TrustManager &#123;</span><br><span class="line">    void checkClientTrusted(X509Certificate[] var1, String var2) throws CertificateException;</span><br><span class="line"></span><br><span class="line">    void checkServerTrusted(X509Certificate[] var1, String var2) throws CertificateException;</span><br><span class="line"></span><br><span class="line">    X509Certificate[] getAcceptedIssuers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkServerTrusted方式实现了对于服务端校验，这里一般使用系统默认的实现，有些教程讲到这样配置ssl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static synchronized SSLSocketFactory getDefaultSSLSocketFactory() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">        sslContext.init(null, new TrustManager[]&#123;</span><br><span class="line">                new X509TrustManager() &#123;</span><br><span class="line">                    public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">                        return new X509Certificate[0];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, null);</span><br><span class="line">        return sslContext.getSocketFactory();</span><br><span class="line">    &#125; catch (GeneralSecurityException e) &#123;</span><br><span class="line">        throw new AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>千万不能这么做，这样将你是没有做任何校验的，这里推荐使用系统默认的，他会在校验过程中发现有异常直接抛出。</p>
<h3 id="HostnameVerifier"><a href="#HostnameVerifier" class="headerlink" title="HostnameVerifier:"></a>HostnameVerifier:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HostnameVerifier &#123;</span><br><span class="line">    boolean verify(String var1, SSLSession var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口主要实现对于域名的校验，OKHTTP实现了一个OkHostnameVerifier，对于证书中的IP及Host做了各种正则匹配，默认情况下使用的是这个策略。有时你遇到了一些奇怪的校验问题，大部分教程会教你这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OKHttpClient.Builder.hostnameVerifier(new HostnameVerifier() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean verify(String hostname, SSLSession session) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>
<p>其实这样你是完全放弃了hostname的校验，这也是相当不安全的。</p>
</div></article></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Hexo</a><p class="is-size-7"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>